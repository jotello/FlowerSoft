"use strict";

var _path = _interopRequireDefault(require("path"));

var _deasync = _interopRequireDefault(require("deasync"));

var _requireRelative = _interopRequireDefault(require("require-relative"));

var _FileUtils = _interopRequireDefault(require("../FileUtils"));

var _Importer = _interopRequireDefault(require("../Importer"));

var _ModuleFinder = _interopRequireDefault(require("../ModuleFinder"));

var _normalizePath = _interopRequireDefault(require("../normalizePath"));

var _readFile = _interopRequireDefault(require("../readFile"));

var _requireResolve = _interopRequireDefault(require("../requireResolve"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

jest.mock('require-relative');
jest.mock('../FileUtils');
jest.mock('../requireResolve');
jest.mock('../readFile');
describe('Importer', function () {
  var word;
  var text;
  var existingFiles;
  var packageJsonContent;
  var packageDependencies;
  var pathToCurrentFile;
  var configuration;
  var setup;
  var moduleFinder;
  beforeEach(function () {
    moduleFinder = _ModuleFinder.default.getForWorkingDirectory(process.cwd(), {
      excludes: [],
      ignorePackagePrefixes: []
    });
    return moduleFinder.initializeStorage(':memory:');
  });
  afterEach(function () {
    return moduleFinder.storage.close();
  });
  beforeEach(function () {
    word = 'foo';
    text = 'foo';
    existingFiles = [];
    packageJsonContent = {};
    packageDependencies = [];
    pathToCurrentFile = 'test.js';
    configuration = {};

    _readFile.default.mockImplementation(function (file) {
      if (/\.json$/.test(file)) {
        return Promise.resolve('{}');
      }

      return Promise.resolve('export default {}');
    });

    setup = function setup() {
      if (Object.keys(configuration).length) {
        _FileUtils.default.__setFile(_path.default.join(process.cwd(), '.importjs.js'), configuration);
      } // Convert the array to an object, as it is in the package.json file.


      var dependencies = packageDependencies.reduce(function (depsObj, dependency) {
        return Object.assign({}, depsObj, _defineProperty({}, dependency, '1.0.0'));
      }, {});

      _FileUtils.default.__setFile(_path.default.join(process.cwd(), 'package.json'), {
        dependencies: dependencies
      });

      _FileUtils.default.__setFileFallback(function (file) {
        if (file in packageJsonContent) {
          return packageJsonContent[file];
        }

        for (var i = 0; i < packageDependencies.length; i += 1) {
          var dep = packageDependencies[i];

          if (file.indexOf(dep) !== -1) {
            return {
              main: "".concat(dep, "-main.jsx")
            };
          }
        }

        return null;
      });

      packageDependencies.forEach(function (dep) {
        _requireResolve.default.__addResolvedPath(_path.default.join(process.cwd(), 'node_modules', dep), _path.default.join(process.cwd(), 'node_modules', dep, "".concat(dep, "-main.jsx")));
      });
      var error;
      var done = false;
      moduleFinder.handleFilesAdded(existingFiles.map(function (f) {
        return {
          path: (0, _normalizePath.default)(f, process.cwd()),
          mtime: Date.now()
        };
      })).then(function () {
        return moduleFinder.handleFilesAdded(packageDependencies.map(function (dep) {
          return {
            path: (0, _normalizePath.default)(_path.default.join('node_modules', dep, "".concat(dep, "-main.jsx")), process.cwd()),
            mtime: Date.now(),
            packageName: dep
          };
        }));
      }).then(function () {
        done = true;
      }).catch(function (promiseError) {
        error = promiseError;
        done = true;
      });

      _deasync.default.loopWhile(function () {
        return !done;
      });

      if (error) {
        throw new Error(error.stack);
      }
    };
  });
  afterEach(function () {
    _FileUtils.default.__reset();

    _requireResolve.default.__reset();
  });
  it('has a message about unknown configuration', function () {
    configuration = {
      somethingStrange: 'foo'
    };
    setup();
    var importer = new _Importer.default(text.split('\n'), pathToCurrentFile, process.cwd());
    expect(importer.messages).toEqual(['Unknown configuration: `somethingStrange`']);
  });
  describe('#import', function () {
    var subject;
    var result;
    beforeEach(function () {
      subject = function subject() {
        setup();
        var error;
        var done = false;
        new _Importer.default(text.split('\n'), pathToCurrentFile, process.cwd()).import(word).then(function (promiseResult) {
          result = promiseResult;
          done = true;
        }).catch(function (promiseError) {
          error = promiseError;
          done = true;
        });

        _deasync.default.loopWhile(function () {
          return !done;
        });

        if (error) {
          throw new Error(error.stack);
        }

        return result.fileContent;
      };
    });
    describe('with a variable name that will not resolve', function () {
      it('leaves the buffer unchanged', function () {
        expect(subject()).toEqual(text);
      });
      it('displays a message', function () {
        subject();
        expect(result.messages).toEqual(["No JS module to import for `".concat(word, "`")]);
      });
      it('does not ask you to resolve manually', function () {
        subject();
        expect(result.unresolvedImports).toEqual({});
      });
    });
    describe('with a variable name that will resolve', function () {
      beforeEach(function () {
        existingFiles = ['bar/foo.jsx'];
      });
      it('adds an import to the top of the buffer', function () {
        expect(subject()).toEqual("\nimport foo from './bar/foo';\n\nfoo\n        ".trim());
      });
      it('displays a message about the imported module', function () {
        subject();
        expect(result.messages).toEqual(["Imported foo from './bar/foo'"]);
      });
      describe('when that import is already imported', function () {
        beforeEach(function () {
          text = "\nimport foo from './bar/foo';\n\nfoo\n          ".trim();
        });
        it('leaves the buffer unchanged', function () {
          expect(subject()).toEqual(text);
        });
      });
      it("adds the import below existing 'use strict'", function () {
        text = "\n'use strict';\n\nfoo\n        ".trim();
        expect(subject()).toEqual("\n'use strict';\n\nimport foo from './bar/foo';\n\nfoo\n          ".trim());
      });
      it("adds the import below two existing 'use strict's", function () {
        text = "\n'use strict';\n'use strict';\n\nfoo\n        ".trim();
        expect(subject()).toEqual("\n'use strict';\n'use strict';\n\nimport foo from './bar/foo';\n\nfoo\n          ".trim());
      });
      it("adds the import with other imports under 'use strict'", function () {
        text = "\n'use strict';\nimport bar from './bar';\n\nfoo + bar\n        ".trim();
        expect(subject()).toEqual("\n'use strict';\nimport bar from './bar';\nimport foo from './bar/foo';\n\nfoo + bar\n        ".trim());
      });
      it("adds a newline when there is no newline under 'use strict'", function () {
        text = "\n'use strict';\nfoo + bar\n        ".trim();
        expect(subject()).toEqual("\n'use strict';\nimport foo from './bar/foo';\n\nfoo + bar\n        ".trim());
      });
      it('adds the import below "use strict" in double quotes', function () {
        text = "\n\"use strict\";\n\nfoo\n        ".trim();
        expect(subject()).toEqual("\n\"use strict\";\n\nimport foo from './bar/foo';\n\nfoo\n        ".trim());
      });
      it('adds the import below a one-line comment at the top of the file', function () {
        text = "\n// One-line comment\n\nfoo\n        ".trim();
        expect(subject()).toEqual("\n// One-line comment\n\nimport foo from './bar/foo';\n\nfoo\n          ".trim());
      });
      it('adds the import below multiple one-line comments at the top of the file', function () {
        text = "\n// One-line comment\n// Another one-line comment\n\nfoo\n        ".trim();
        expect(subject()).toEqual("\n// One-line comment\n// Another one-line comment\n\nimport foo from './bar/foo';\n\nfoo\n          ".trim());
      });
      it('adds the import below an empty line after a comment', function () {
        text = "\n// One-line comment\n\nfoo\n        ".trimRight();
        expect(subject()).toEqual("\n// One-line comment\n\nimport foo from './bar/foo';\n\nfoo\n          ".trim());
      });
      it('adds the import below one-line comments with empty lines', function () {
        text = "\n// One-line comment\n\n// Another one-line comment\n\nfoo\n        ".trim();
        expect(subject()).toEqual("\n// One-line comment\n\n// Another one-line comment\n\nimport foo from './bar/foo';\n\nfoo\n          ".trim());
      });
      it('adds the import below multi-line comments at the top of the file', function () {
        text = "\n/* Multi-line comment */\n\nfoo\n        ".trim();
        expect(subject()).toEqual("\n/* Multi-line comment */\n\nimport foo from './bar/foo';\n\nfoo\n          ".trim());
      });
      it('adds the import below a multi-line comment spanning lines', function () {
        text = "\n/*\nMulti-line comment\nthat spans multiple lines\n*/\n\nfoo\n        ".trim();
        expect(subject()).toEqual("\n/*\nMulti-line comment\nthat spans multiple lines\n*/\n\nimport foo from './bar/foo';\n\nfoo\n          ".trim());
      });
      it('adds the import below weirdly stacked multi-line comments', function () {
        text = "\n/* Single-line multi-line comment *//*\nMulti-line comment\nthat spans multiple lines\n*/\n\nfoo\n        ".trim();
        expect(subject()).toEqual("\n/* Single-line multi-line comment *//*\nMulti-line comment\nthat spans multiple lines\n*/\n\nimport foo from './bar/foo';\n\nfoo\n          ".trim());
      });
      it('adds the import below both comment styles at the top of the file', function () {
        text = "\n// One-line comment\n/* Multi-line comment */\n\nfoo\n        ".trim();
        expect(subject()).toEqual("\n// One-line comment\n/* Multi-line comment */\n\nimport foo from './bar/foo';\n\nfoo\n          ".trim());
      });
      it("adds the import below both styles of comments and 'use strict'", function () {
        text = "\n'use strict';\n// One-line comment\n/* Multi-line comment */\n\nfoo\n        ".trim();
        expect(subject()).toEqual("\n'use strict';\n// One-line comment\n/* Multi-line comment */\n\nimport foo from './bar/foo';\n\nfoo\n        ".trim());
      });
      describe('when sorting and grouping are disabled', function () {
        beforeEach(function () {
          configuration.groupImports = false;
          configuration.sortImports = false;
        });
        it('leaves newlines', function () {
          text = "\nimport bar from './bar';\n\nimport baz from './bar/baz';\n\nfoo\n          ".trim();
          expect(subject()).toEqual("\nimport foo from './bar/foo';\nimport bar from './bar';\n\nimport baz from './bar/baz';\n\nfoo\n          ".trim());
        });
        it('leaves single-line comments', function () {
          text = "\nimport bar from './bar';\n\n// Comment\nimport baz from './bar/baz';\n\nfoo\n          ".trim();
          expect(subject()).toEqual("\nimport foo from './bar/foo';\nimport bar from './bar';\n\n// Comment\nimport baz from './bar/baz';\n\nfoo\n          ".trim());
        });
        it('leaves content before imports', function () {
          text = "\n'use strict';\n// Comment A\n\n// Comment B\nimport bar from './bar';\nimport baz from './bar/baz';\n\nfoo\n          ".trim();
          expect(subject()).toEqual("\n'use strict';\n// Comment A\n\n// Comment B\nimport foo from './bar/foo';\nimport bar from './bar';\nimport baz from './bar/baz';\n\nfoo\n          ".trim());
        });
        it('leaves multiple single-line comments', function () {
          text = "\nimport bar from './bar';\n\n// Comment A\n// Comment B\nimport baz from './bar/baz';\n\nfoo\n          ".trim();
          expect(subject()).toEqual("\nimport foo from './bar/foo';\nimport bar from './bar';\n\n// Comment A\n// Comment B\nimport baz from './bar/baz';\n\nfoo\n          ".trim());
        });
        it('leaves 1-line multi-line comments', function () {
          text = "\nimport bar from './bar';\n\n/* Comment */\nimport baz from './bar/baz';\n\nfoo\n          ".trim();
          expect(subject()).toEqual("\nimport foo from './bar/foo';\nimport bar from './bar';\n\n/* Comment */\nimport baz from './bar/baz';\n\nfoo\n          ".trim());
        });
        it('leaves n-line multi-line comments', function () {
          text = "\nimport bar from './bar';\n\n/* Comment\n * 123\n */\nimport baz from './bar/baz';\n\nfoo\n          ".trim();
          expect(subject()).toEqual("\nimport foo from './bar/foo';\nimport bar from './bar';\n\n/* Comment\n * 123\n */\nimport baz from './bar/baz';\n\nfoo\n          ".trim());
        });
      });
      describe('when the variable name matches last folder+filename', function () {
        beforeEach(function () {
          existingFiles = ['sko/bar/foo.jsx'];
          word = 'barFoo';
          text = 'barFoo';
        });
        it('resolves the import', function () {
          expect(subject()).toEqual("\nimport barFoo from './sko/bar/foo';\n\nbarFoo\n          ".trim());
        });
        describe('when the last folder ends with an "s"', function () {
          beforeEach(function () {
            existingFiles = ['sko/bars/foo.jsx'];
          });
          it('resolves the import', function () {
            expect(subject()).toEqual("\nimport barFoo from './sko/bars/foo';\n\nbarFoo\n            ".trim());
          });
          describe('when the variable also has "s" at the end', function () {
            beforeEach(function () {
              word = 'barsFoo';
              text = 'barsFoo';
            });
            it('resolves the import', function () {
              expect(subject()).toEqual("\nimport barsFoo from './sko/bars/foo';\n\nbarsFoo\n              ".trim());
            });
          });
        });
        describe('when the last folder ends with "es"', function () {
          beforeEach(function () {
            existingFiles = ['sko/statuses/foo.jsx'];
            word = 'statusFoo';
            text = 'statusFoo';
          });
          it('resolves the import', function () {
            expect(subject()).toEqual("\nimport statusFoo from './sko/statuses/foo';\n\nstatusFoo\n            ".trim());
          });
          describe('when the variable also has "es" at the end', function () {
            beforeEach(function () {
              word = 'statusesFoo';
              text = 'statusesFoo';
            });
            it('resolves the import', function () {
              expect(subject()).toEqual("\nimport statusesFoo from './sko/statuses/foo';\n\nstatusesFoo\n              ".trim());
            });
          });
        });
      });
      describe('when the variable resolves to a node.js conventional module', function () {
        beforeEach(function () {
          existingFiles = ['Foo/index.jsx'];
        });
        it('adds an import to the top of the buffer', function () {
          expect(subject()).toEqual("\nimport foo from './Foo';\n\nfoo\n          ".trim());
        });
        it('displays a message about the imported module', function () {
          subject();
          expect(result.messages).toEqual(["Imported foo from './Foo'"]);
        });
        describe('when that module has a dot in its name', function () {
          beforeEach(function () {
            existingFiles = ['Foo.io/index.jsx'];
            word = 'FooIO';
            text = 'FooIO';
          });
          it('imports that module with the dot', function () {
            expect(subject()).toEqual("\nimport FooIO from './Foo.io';\n\nFooIO\n            ".trim());
          });
        });
      });
      describe('in a meteor environment', function () {
        beforeEach(function () {
          configuration.namedExports = {
            'meteor/meteor': ['Meteor']
          };
          word = 'Meteor';
          text = "\nimport Gadget from 'gadget';\n\nMeteor\n          ".trim();
          configuration.environments = ['meteor'];
        });
        it('adds an import to the top of the buffer', function () {
          expect(subject()).toEqual("\nimport { Meteor } from 'meteor/meteor';\n\nimport Gadget from 'gadget';\n\nMeteor\n          ".trim());
        });
      });
      it('adds a require to the top of the buffer in a node environment', function () {
        word = 'Readline';
        text = 'Readline';
        configuration.environments = ['node'];
        expect(subject()).toEqual("\nconst Readline = require('readline');\n\nReadline\n        ".trim());
      });
      describe('when the import resolves to a dependency from package.json', function () {
        beforeEach(function () {
          packageDependencies = ['foo-bar'];
          word = 'fooBar';
          text = 'fooBar';
        });
        it('adds an import to the top of the buffer', function () {
          expect(subject()).toEqual("\nimport fooBar from 'foo-bar';\n\nfooBar\n          ".trim());
        });
        it('displays a message about the imported module', function () {
          subject();
          expect(result.messages).toEqual(["Imported fooBar from 'foo-bar'"]);
        });
        describe('when there is an exclude', function () {
          beforeEach(function () {
            configuration.excludes = ['./node_modules/foo-bar/*'];
          });
          afterEach(function () {
            configuration.excludes = [];
          });
          it('excludes the import', function () {
            expect(subject()).toEqual("\nfooBar\n            ".trim());
          });
        });
      });
      describe('when other imports exist', function () {
        beforeEach(function () {
          text = "\nimport zoo from './foo/zoo';\nimport bar from './foo/bar';\n\nfoo\n          ".trim();
        });
        it('adds the import and sorts the entire list', function () {
          expect(subject()).toEqual("\nimport bar from './foo/bar';\nimport foo from './bar/foo';\nimport zoo from './foo/zoo';\n\nfoo\n          ".trim());
        });
        describe('when there are unconventional imports in the list', function () {
          // e.g. added through using the `importFunction` configuration option
          beforeEach(function () {
            text = "\nconst sko = customImportFunction('./sko');\nimport * as starBar from './star/bar';\nimport zoo from './foo/zoo'\nimport bar from './foo/bar';\n\nfoo\n            ".trim();
          });
          it('adds the import and sorts the entire list with groups', function () {
            expect(subject()).toEqual("\nimport bar from './foo/bar';\nimport foo from './bar/foo';\nimport * as starBar from './star/bar';\nimport zoo from './foo/zoo'\n\nconst sko = customImportFunction('./sko');\n\nfoo\n            ".trim());
          });
          describe('and `groupImports` is false', function () {
            beforeEach(function () {
              configuration.groupImports = false;
            });
            it('adds the import and sorts all of them', function () {
              expect(subject()).toEqual("\nimport bar from './foo/bar';\nimport foo from './bar/foo';\nconst sko = customImportFunction('./sko');\nimport * as starBar from './star/bar';\nimport zoo from './foo/zoo'\n\nfoo\n              ".trim());
            });
          });
        });
      });
      describe('when there is an unconventional import', function () {
        beforeEach(function () {
          text = "\nimport zoo from './foo/zoo';\nconst tsar = require('./foo/bar').tsa;\n\nfoo\n          ".trim();
        });
        it('adds the import and moves out the unconventional import', function () {
          expect(subject()).toEqual("\nimport foo from './bar/foo';\nimport zoo from './foo/zoo';\n\nconst tsar = require('./foo/bar').tsa;\n\nfoo\n        ".trim());
        });
      });
      describe('when there is a non-import inline with the imports', function () {
        beforeEach(function () {
          text = "\nimport bar from './bar';\nimport star from\n  './star';\nvar { STRAWBERRY, CHOCOLATE } = bar.scoops;\nimport zoo from './foo/zoo';\n\nfoo\n          ".trim();
        });
        it('breaks imports at that line', function () {
          // A better solution would perhaps be to find the `var zoo` import and
          // move it up there with the rest. But there's a lot of complexity
          // involved in that, so cutting off at the non-import is a simpler
          // solution.
          expect(subject()).toEqual("\nimport bar from './bar';\nimport foo from './bar/foo';\nimport star from\n  './star';\n\nvar { STRAWBERRY, CHOCOLATE } = bar.scoops;\nimport zoo from './foo/zoo';\n\nfoo\n        ".trim());
        });
      });
      describe('when there is an import with line-breaks', function () {
        beforeEach(function () {
          text = "\nimport zoo from\n  './foo/zoo';\nimport tsar from './foo/bar';\n\nvar import_foo = { from: b }\n          ".trim();
        });
        it('adds the import, sorts the entire list and keeps the line-break', function () {
          expect(subject()).toEqual("\nimport foo from './bar/foo';\nimport tsar from './foo/bar';\nimport zoo from\n  './foo/zoo';\n\nvar import_foo = { from: b }\n        ".trim());
        });
      });
      describe('when there is a blank line amongst current imports', function () {
        beforeEach(function () {
          text = "\nimport zoo from './foo/zoo';\n\nimport bar from './foo/bar';\nfoo\n          ".trim();
        });
        it('adds the import, compacts, and sorts the entire list', function () {
          expect(subject()).toEqual("\nimport bar from './foo/bar';\nimport foo from './bar/foo';\nimport zoo from './foo/zoo';\n\nfoo\n          ".trim());
        });
      });
      describe('when there are multiple blank lines amongst current imports', function () {
        beforeEach(function () {
          text = "\nimport zoo from './foo/zoo';\n\nimport frodo from './bar/frodo';\n\n\nimport bar from './foo/bar';\n\nfoo\n          ".trim();
        });
        it('compacts the list', function () {
          expect(subject()).toEqual("\nimport bar from './foo/bar';\nimport foo from './bar/foo';\nimport frodo from './bar/frodo';\nimport zoo from './foo/zoo';\n\nfoo\n          ".trim());
        });
      });
      describe('when multiple files resolve the variable', function () {
        beforeEach(function () {
          existingFiles = ['bar/foo.jsx', 'zoo/foo.js', 'zoo/goo/Foo/index.js'];
        });
        it('has no messages', function () {
          subject();
          expect(result.messages).toEqual([]);
        });
        it('records the alternatives to choose from', function () {
          subject();
          expect(result.unresolvedImports).toEqual({
            foo: [{
              displayName: "import foo from './bar/foo';",
              importPath: './bar/foo',
              data: {
                filePath: './bar/foo.jsx',
                importPath: './bar/foo',
                isNamedExport: false
              }
            }, {
              displayName: "import foo from './zoo/foo';",
              importPath: './zoo/foo',
              data: {
                filePath: './zoo/foo.js',
                importPath: './zoo/foo',
                isNamedExport: false
              }
            }, {
              displayName: "import foo from './zoo/goo/Foo';",
              importPath: './zoo/goo/Foo',
              data: {
                filePath: 'zoo/goo/Foo/index.js',
                importPath: './zoo/goo/Foo',
                isNamedExport: false
              }
            }]
          });
        });
      });
      describe('when multiple files resolve the variable', function () {
        beforeEach(function () {
          existingFiles = ['zoo/goo/Foo/index.js', 'bar/foo.jsx'];
        });
        it('sorts the results', function () {
          subject();
          expect(result.unresolvedImports).toEqual({
            foo: [{
              displayName: "import foo from './bar/foo';",
              importPath: './bar/foo',
              data: {
                filePath: './bar/foo.jsx',
                importPath: './bar/foo',
                isNamedExport: false
              }
            }, {
              displayName: "import foo from './zoo/goo/Foo';",
              importPath: './zoo/goo/Foo',
              data: {
                filePath: 'zoo/goo/Foo/index.js',
                importPath: './zoo/goo/Foo',
                isNamedExport: false
              }
            }]
          });
        });
      });
    });
    describe('when there is an export named as the module', function () {
      beforeEach(function () {
        existingFiles = ['bar/foo.js'];

        _readFile.default.mockImplementation(function () {
          return Promise.resolve("\n          export { foo };\n          export default function() {};\n        ");
        });
      });
      it('has no messages', function () {
        subject();
        expect(result.messages).toEqual([]);
      });
      it('records the alternatives to choose from', function () {
        subject();
        expect(result.unresolvedImports).toEqual({
          foo: [{
            displayName: "import foo from './bar/foo';",
            importPath: './bar/foo',
            data: {
              filePath: './bar/foo.js',
              importPath: './bar/foo',
              isNamedExport: false
            }
          }, {
            displayName: "import { foo } from './bar/foo';",
            importPath: './bar/foo',
            data: {
              filePath: './bar/foo.js',
              importPath: './bar/foo',
              isNamedExport: true
            }
          }]
        });
      });
    });
    describe('importing a module with a package.json file', function () {
      beforeEach(function () {
        existingFiles = ['Foo/package.json', 'Foo/build/main.js'];
      });
      describe('when `main` points to a JS file', function () {
        beforeEach(function () {
          packageJsonContent = _defineProperty({}, _path.default.join(process.cwd(), 'Foo/package.json'), {
            main: 'build/main.js'
          });
        });
        it('adds an import to the top of the buffer', function () {
          expect(subject()).toEqual("\nimport foo from './Foo';\n\nfoo\n          ".trim());
        });
      });
      describe('when `main` points to index.js in the same folder', function () {
        beforeEach(function () {
          existingFiles = ['Foo/package.json', 'Foo/index.js'];
          packageJsonContent = _defineProperty({}, _path.default.join(process.cwd(), 'Foo/package.json'), {
            main: 'index.js'
          });
        });
        it('adds an import to the top of the buffer', function () {
          expect(subject()).toEqual("\nimport foo from './Foo';\n\nfoo\n          ".trim());
        });
      });
      describe('when the module is named something.js', function () {
        beforeEach(function () {
          existingFiles = ['Foo.js/package.json', 'Foo.js/main.js'];
          text = 'FooJS';
          word = 'FooJS';
          packageJsonContent = _defineProperty({}, _path.default.join(process.cwd(), 'Foo.js/package.json'), {
            main: 'main.js'
          });
        });
        it('keeps the .js in the import', function () {
          expect(subject()).toEqual("\nimport FooJS from './Foo.js';\n\nFooJS\n          ".trim());
        });
      });
      describe('when `main` is missing', function () {
        beforeEach(function () {
          packageJsonContent = _defineProperty({}, _path.default.join(process.cwd(), 'Foo.js/package.json'), {});
        });
        it('does not add an import', function () {
          expect(subject()).toEqual("\nfoo\n          ".trim());
        });
      });
    });
    describe('line wrapping', function () {
      describe('when lines exceed the configured max width', function () {
        beforeEach(function () {
          configuration.maxLineLength = 40;
          existingFiles = ['fiz/bar/biz/baz/fiz/buz/boz/foo.jsx'];
        });
        describe('when configured to use a tab character', function () {
          beforeEach(function () {
            configuration.tab = '\t';
          });
          it('wraps them and indents with a tab', function () {
            expect(subject()).toEqual("\nimport foo from\n\t'./fiz/bar/biz/baz/fiz/buz/boz/foo';\n\nfoo\n            ".trim());
          });
        });
        describe('when configured to use two spaces', function () {
          beforeEach(function () {
            configuration.tab = '  ';
          });
          it('wraps them and indents with two spaces', function () {
            expect(subject()).toEqual("\nimport foo from\n  './fiz/bar/biz/baz/fiz/buz/boz/foo';\n\nfoo\n            ".trim());
          });
        });
      });
      describe('when lines do not exceed the configured max width', function () {
        beforeEach(function () {
          configuration.maxLineLength = 80;
          existingFiles = ['bar/foo.jsx'];
        });
        it('does not wrap them', function () {
          expect(subject()).toEqual("\nimport foo from './bar/foo';\n\nfoo\n          ".trim());
        });
      });
    });
    describe('configuration', function () {
      describe('with a moduleNameFormatter that manipulates the path', function () {
        beforeEach(function () {
          configuration.moduleNameFormatter = function (_ref) {
            var moduleName = _ref.moduleName;
            return "!foo!".concat(moduleName);
          };

          existingFiles = ['bar/foo.jsx'];
          text = 'foo';
          word = 'foo';
        });
        it('uses the manipulated path', function () {
          expect(subject()).toEqual("\nimport foo from '!foo!./bar/foo';\n\nfoo\n        ".trim());
        });
      });
      describe('with an importStatementFormatter that manipulates the path', function () {
        beforeEach(function () {
          configuration.importStatementFormatter = function (_ref2) {
            var importStatement = _ref2.importStatement;
            return importStatement.replace(/;$/, '');
          };

          existingFiles = ['bar/foo.jsx'];
          text = 'foo';
          word = 'foo';
        });
        it('uses the manipulated statement', function () {
          expect(subject()).toEqual("\nimport foo from './bar/foo'\n\nfoo\n        ".trim());
        });
      });
      describe('with aliases', function () {
        beforeEach(function () {
          configuration.aliases = {
            $: 'jquery'
          };
          packageDependencies = ['jquery'];
          text = '$';
          word = '$';
        });
        it('resolves aliased imports to the aliases', function () {
          expect(subject()).toEqual("\nimport $ from 'jquery';\n\n$\n        ".trim());
        });
        describe('and an alias has a dynamic {filename}', function () {
          beforeEach(function () {
            configuration.aliases = {
              styles: './{filename}.scss'
            };
            text = 'styles';
            word = 'styles';
            pathToCurrentFile = 'bar/foo.jsx';
          });
          it('uses the filename of the current file', function () {
            expect(subject()).toEqual("\nimport styles from './foo.scss';\n\nstyles\n            ".trim());
          });
          describe('when editing an anonymous file', function () {
            describe('that is nil', function () {
              beforeEach(function () {
                pathToCurrentFile = null;
              });
              it('does not replace the dynamic part', function () {
                expect(subject()).toEqual("\nimport styles from './{filename}.scss';\n\nstyles\n                ".trim());
              });
            });
            describe('that is an empty string', function () {
              beforeEach(function () {
                pathToCurrentFile = '';
              });
              it('does not replace the dynamic part', function () {
                expect(subject()).toEqual("\nimport styles from './{filename}.scss';\n\nstyles\n                ".trim());
              });
            });
          });
        });
        describe('and an alias contains a slash', function () {
          // https://github.com/galooshi/import-js/issues/39
          beforeEach(function () {
            configuration.aliases = {
              $: 'jquery/jquery'
            };
          });
          it('keeps the slash in the alias path', function () {
            expect(subject()).toEqual("\nimport $ from 'jquery/jquery';\n\n$\n          ".trim());
          });
        });
      });
      describe('with `namedExports` object', function () {
        beforeEach(function () {
          configuration.namedExports = {
            'lib/utils': ['foo', 'bar']
          };
          text = 'foo';
          word = 'foo';
        });
        describe('when the named export is a node_module', function () {
          beforeEach(function () {
            _requireResolve.default.__addResolvedPath('lib/utils', _path.default.join(process.cwd(), 'node_modules/lib/utils.js'));
          });
          it('resolves that import and uses a non-relative path', function () {
            expect(subject()).toEqual("\nimport { foo } from 'lib/utils';\n\nfoo\n            ".trim());
          });
        });
        describe('when the named export is a regular file', function () {
          beforeEach(function () {
            _requireResolve.default.__addResolvedPath('lib/utils', _path.default.join(process.cwd(), 'lib/utils.js'));
          });
          it('resolves that import', function () {
            expect(subject()).toEqual("\nimport { foo } from 'lib/utils';\n\nfoo\n            ".trim());
          });
        });
      });
      describe('with `namedExports` meteor object', function () {
        beforeEach(function () {
          configuration.namedExports = {
            'meteor/meteor': ['Meteor']
          };
          text = 'Meteor';
          word = 'Meteor';
        });
        describe('when the named export is a meteor package', function () {
          beforeEach(function () {
            _requireResolve.default.__addResolvedPath('meteor/meteor', '');
          });
          it('resolves that import and uses a non-relative path', function () {
            expect(subject()).toEqual("\nimport { Meteor } from 'meteor/meteor';\n\nMeteor\n            ".trim());
          });
        });
      });
      describe('using `var`, `aliases` and a `namedExports` object', function () {
        beforeEach(function () {
          packageDependencies = ['underscore'];
          configuration = Object.assign(configuration, {
            declarationKeyword: 'var',
            namedExports: {
              underscore: ['memoize', 'debounce']
            },
            aliases: {
              _: 'underscore'
            }
          });
          text = '_';
          word = '_';
        });
        it('resolves the main alias without destructuring', function () {
          expect(subject()).toEqual("\nvar _ = require('underscore');\n\n_\n        ".trim());
        });
        describe('when a named import exists for the same module', function () {
          beforeEach(function () {
            text = "\nvar { memoize } = require('underscore');\n\n_\n            ".trim();
          });
          it('adds the default import', function () {
            expect(subject()).toEqual("\nvar _ = require('underscore');\nvar { memoize } = require('underscore');\n\n_\n            ".trim());
          });
        });
        describe('when importing a named export', function () {
          beforeEach(function () {
            text = 'memoize';
            word = 'memoize';
          });
          it('resolves that import using destructuring', function () {
            expect(subject()).toEqual("\nvar { memoize } = require('underscore');\n\nmemoize\n            ".trim());
          });
          it('displays a message about the imported module', function () {
            subject();
            expect(result.messages).toContain("Imported { memoize } from 'underscore'");
          });
          describe('when the default import exists for the same module', function () {
            beforeEach(function () {
              text = "\nvar _ = require('underscore');\n\nmemoize\n              ".trim();
            });
            it('adds the destructuring on a new line', function () {
              expect(subject()).toEqual("\nvar _ = require('underscore');\nvar { memoize } = require('underscore');\n\nmemoize\n              ".trim());
            });
          });
          describe('when the default is already imported for destructured var', function () {
            beforeEach(function () {
              text = "\nvar _ = require('underscore');\n\nvar foo = require('foo');\n\nmemoize\n              ".trim();
            });
            it('adds the destructuring on a new line', function () {
              expect(subject()).toEqual("\nvar _ = require('underscore');\nvar { memoize } = require('underscore');\n\nvar foo = require('foo');\n\nmemoize\n              ".trim());
            });
          });
          describe('with other imports', function () {
            beforeEach(function () {
              packageDependencies.push('alphabet');
            });
            beforeEach(function () {
              text = "\nconst bar = require('foo/bar');\nvar { xyz } = require('alphabet');\n\nmemoize\n              ".trim();
            });
            it('places the import at the right place', function () {
              expect(subject()).toEqual("\nconst bar = require('foo/bar');\n\nvar { memoize } = require('underscore');\nvar { xyz } = require('alphabet');\n\nmemoize\n              ".trim());
            });
          });
          describe('when other destructured imports exist for the same module', function () {
            beforeEach(function () {
              text = "\nvar { xyz, debounce } = require('underscore');\n\nmemoize\n              ".trim();
            });
            it('combines the destructured import and sorts items', function () {
              expect(subject()).toEqual("\nvar { debounce, memoize, xyz } = require('underscore');\n\nmemoize\n              ".trim());
            });
            describe('when the module is already in the destructured object', function () {
              beforeEach(function () {
                text = "\nvar { debounce, memoize } = require('underscore');\n\nmemoize\n                ".trim();
              });
              it('does not add a duplicate', function () {
                expect(subject()).toEqual("\nvar { debounce, memoize } = require('underscore');\n\nmemoize\n                ".trim());
              });
            });
          });
        });
      });
      describe('alias with `import` and a `namedExports` object', function () {
        beforeEach(function () {
          packageDependencies = ['underscore'];
          configuration = Object.assign(configuration, {
            declarationKeyword: 'import',
            namedExports: {
              underscore: ['memoize', 'debounce']
            },
            aliases: {
              _: 'underscore'
            }
          });
          text = '_';
          word = '_';
        });
        it('resolves the main alias without a named import', function () {
          expect(subject()).toEqual("\nimport _ from 'underscore';\n\n_\n          ".trim());
        });
        describe('when a named import exists for the same module', function () {
          beforeEach(function () {
            text = "\nimport { memoize } from 'underscore';\n\n_\n            ".trim();
          });
          it('adds the default import', function () {
            expect(subject()).toEqual("\nimport _, { memoize } from 'underscore';\n\n_\n            ".trim());
          });
        });
        describe('when importing a named export', function () {
          beforeEach(function () {
            text = 'memoize';
            word = 'memoize';
          });
          it('uses a named import', function () {
            expect(subject()).toEqual("\nimport { memoize } from 'underscore';\n\nmemoize\n            ".trim());
          });
          describe('with other imports', function () {
            beforeEach(function () {
              packageDependencies.push('alphabet');
              text = "\nimport { xyz } from 'alphabet';\n\nimport bar from 'foo/bar';\n\nmemoize\n              ".trim();
            });
            it('places the import at the right place', function () {
              expect(subject()).toEqual("\nimport { memoize } from 'underscore';\nimport { xyz } from 'alphabet';\n\nimport bar from 'foo/bar';\n\nmemoize\n              ".trim());
            });
          });
          describe('when other named imports exist for the same module', function () {
            beforeEach(function () {
              text = "\nimport { xyz, debounce } from 'underscore';\n\nmemoize\n              ".trim();
            });
            it('combines the named import and sorts items', function () {
              expect(subject()).toEqual("\nimport { debounce, memoize, xyz } from 'underscore';\n\nmemoize\n              ".trim());
            });
            describe('when the module is already in the named imports', function () {
              beforeEach(function () {
                text = "\nimport { debounce, memoize, xyz } from 'underscore';\n\nmemoize\n                ".trim();
              });
              it('does not add a duplicate', function () {
                expect(subject()).toEqual("\nimport { debounce, memoize, xyz } from 'underscore';\n\nmemoize\n                ".trim());
              });
            });
          });
          describe('when a default import exists for the same module', function () {
            beforeEach(function () {
              text = "\nimport _ from 'underscore';\n\nmemoize\n              ".trim();
            });
            it('adds the named import', function () {
              expect(subject()).toEqual("\nimport _, { memoize } from 'underscore';\n\nmemoize\n              ".trim());
            });
            describe('when the module is already in the named import', function () {
              beforeEach(function () {
                text = "\nimport _, { memoize } from 'underscore';\n\nmemoize\n                ".trim();
              });
              it('does not add a duplicate', function () {
                expect(subject()).toEqual("\nimport _, { memoize } from 'underscore';\n\nmemoize\n                ".trim());
              });
            });
          });
        });
      });
      describe('with a custom `importFunction`', function () {
        beforeEach(function () {
          existingFiles = ['bar/foo.js'];
        });
        describe('and `declarationKeyword=import`', function () {
          beforeEach(function () {
            configuration.importFunction = 'myRequire';
            configuration.declarationKeyword = 'import';
          });
          it('does nothing special', function () {
            expect(subject()).toEqual("\nimport foo from './bar/foo';\n\nfoo\n            ".trim());
          });
        });
        describe('and `declarationKeyword=const`', function () {
          beforeEach(function () {
            configuration.importFunction = 'myRequire';
            configuration.declarationKeyword = 'const';
          });
          it('uses the custom import function instead of "require"', function () {
            expect(subject()).toEqual("\nconst foo = myRequire('./bar/foo');\n\nfoo\n            ".trim());
          });
        });
      });
      describe('when stripFileExtensions is empty', function () {
        beforeEach(function () {
          existingFiles = ['bar/foo.js'];
          configuration.stripFileExtensions = [];
        });
        it('keeps the file ending in the import', function () {
          expect(subject()).toEqual("\nimport foo from './bar/foo.js';\n\nfoo\n          ".trim());
        });
      });
      describe('with declarationKeyword=const', function () {
        beforeEach(function () {
          configuration.declarationKeyword = 'const';
        });
        describe('with a variable name that will resolve', function () {
          beforeEach(function () {
            existingFiles = ['bar/foo.jsx'];
          });
          it('adds an import to the top using the declarationKeyword', function () {
            expect(subject()).toEqual("\nconst foo = require('./bar/foo');\n\nfoo\n            ".trim());
          });
          describe('when that variable is already imported using `var`', function () {
            beforeEach(function () {
              text = "\nvar foo = require('./bar/foo');\n\nfoo\n              ".trim();
            });
            it('changes the `var` to declarationKeyword', function () {
              expect(subject()).toEqual("\nconst foo = require('./bar/foo');\n\nfoo\n              ".trim());
            });
          });
          describe('when the import contains a line-break', function () {
            beforeEach(function () {
              text = "\nvar foo =\n  require('./bar/foo');\n\nfoo\n              ".trim();
            });
            it('changes the `var` to declarationKeyword and removes space', function () {
              expect(subject()).toEqual("\nconst foo = require('./bar/foo');\n\nfoo\n              ".trim());
            });
          });
          describe('when other imports exist', function () {
            beforeEach(function () {
              text = "\nvar zoo = require('foo/zoo');\nlet bar = require('foo/bar');\n\nfoo\n              ".trim();
            });
            it('adds the import and sorts and groups the entire list', function () {
              expect(subject()).toEqual("\nconst foo = require('./bar/foo');\n\nvar zoo = require('foo/zoo');\n\nlet bar = require('foo/bar');\n\nfoo\n            ".trim());
            });
          });
        });
      });
      describe('with declarationKeyword=import', function () {
        beforeEach(function () {
          configuration.declarationKeyword = 'import';
        });
        describe('with a variable name that will resolve', function () {
          beforeEach(function () {
            existingFiles = ['bar/foo.jsx', 'bar/fromfoo.jsx'];
          });
          describe('when that variable is already imported using `var`', function () {
            beforeEach(function () {
              text = "\nvar foo = require('./bar/foo');\n\nfoo\n              ".trim();
            });
            it('changes the `var` to declarationKeyword', function () {
              expect(subject()).toEqual("\nimport foo from './bar/foo';\n\nfoo\n              ".trim());
            });
          });
          describe('when that variable already exists with a different style', function () {
            beforeEach(function () {
              text = "\nvar foo = require(\"./bar/foo\");\n\nfoo\n              ".trim();
            });
            it('changes `var` to declarationKeyword and doubles to singles', function () {
              expect(subject()).toEqual("\nimport foo from './bar/foo';\n\nfoo\n              ".trim());
            });
          });
          describe('when the imported variable has "from" in it', function () {
            beforeEach(function () {
              word = 'fromfoo';
              text = "\nvar fromfoo = require('./bar/fromfoo');\n\nfromfoo\n              ".trim();
            });
            it('changes the `var` to declarationKeyword', function () {
              expect(subject()).toEqual("\nimport fromfoo from './bar/fromfoo';\n\nfromfoo\n              ".trim());
            });
          });
          describe('when the import contains a line-break', function () {
            beforeEach(function () {
              text = "\nvar foo =\n  require('./bar/foo');\n\nfoo\n              ".trim();
            });
            it('changes the `var` to declarationKeyword and removes space', function () {
              expect(subject()).toEqual("\nimport foo from './bar/foo';\n\nfoo\n              ".trim());
            });
          });
          describe('when other imports exist', function () {
            beforeEach(function () {
              text = "\nvar zoo = require('foo/zoo');\nlet bar = require('foo/bar');\n\nfoo\n              ".trim();
            });
            it('adds the import and sorts and groups the entire list', function () {
              expect(subject()).toEqual("\nimport foo from './bar/foo';\n\nvar zoo = require('foo/zoo');\n\nlet bar = require('foo/bar');\n\nfoo\n            ".trim());
            });
          });
        });
      });
      describe('in a meteor environment', function () {
        beforeEach(function () {
          configuration.environments = ['meteor'];
          existingFiles = ['bar/foo.jsx'];
          text = 'foo';
        });
        describe('with `useRelativePaths=true`', function () {
          beforeEach(function () {
            configuration.useRelativePaths = true;
          });
          it('uses a relative import path', function () {
            expect(subject()).toEqual("\nimport foo from './bar/foo';\n\nfoo\n            ".trim());
          });
          describe('when the current file is an absolute path', function () {
            beforeEach(function () {
              pathToCurrentFile = "".concat(process.cwd(), "/bar/test.js");
            });
            it('uses a relative import path', function () {
              expect(subject()).toEqual("\nimport foo from './foo';\n\nfoo\n              ".trim());
            });
          });
        });
        describe('with `useRelativePaths=false`', function () {
          beforeEach(function () {
            configuration.useRelativePaths = false;
          });
          it('uses an absolute import path', function () {
            expect(subject()).toEqual("\nimport foo from '/bar/foo';\n\nfoo\n            ".trim());
          });
        });
      });
      describe('with `useRelativePaths=true`', function () {
        beforeEach(function () {
          existingFiles = ['bar/foo.jsx'];
          text = 'foo';
          configuration.useRelativePaths = true;
        });
        it('uses a relative import path', function () {
          expect(subject()).toEqual("\nimport foo from './bar/foo';\n\nfoo\n          ".trim());
        });
      });
    });
  });
  describe('#addImports', function () {
    var subject;
    var resolvedImports;
    var result;
    beforeEach(function () {
      subject = function subject() {
        setup();
        var error;
        var done = false;
        new _Importer.default(text.split('\n'), pathToCurrentFile, process.cwd()).addImports(resolvedImports).then(function (promiseResult) {
          result = promiseResult;
          done = true;
        }).catch(function (promiseError) {
          error = promiseError;
          done = true;
        });

        _deasync.default.loopWhile(function () {
          return !done;
        });

        if (error) {
          throw new Error(error.stack);
        }

        return result.fileContent;
      };
    });
    describe('when adding one import', function () {
      beforeEach(function () {
        text = 'foo';
        existingFiles = ['./star/foo.js'];
        resolvedImports = {
          foo: './star/foo'
        };
      });
      it('adds imports based on variable name and import path', function () {
        expect(subject()).toEqual("\nimport foo from './star/foo';\n\nfoo\n        ".trim());
      });
      it('displays a message', function () {
        subject();
        expect(result.messages).toEqual(['Added import for `foo`']);
      });
      describe('when the resolved import is named', function () {
        beforeEach(function () {
          _readFile.default.mockImplementation(function () {
            return Promise.resolve('export { foo };');
          });
        });
        it('adds imports based on variable name and import path', function () {
          expect(subject()).toEqual("\nimport { foo } from './star/foo';\n\nfoo\n          ".trim());
        });
      });
    });
    describe('when adding multiple imports', function () {
      beforeEach(function () {
        text = 'foo; bar;';
        resolvedImports = {
          foo: 'star/foo',
          bar: 'star/bar'
        };
      });
      it('adds imports based on variable name and import path', function () {
        expect(subject()).toEqual("\nimport bar from 'star/bar';\nimport foo from 'star/foo';\n\nfoo; bar;\n        ".trim());
      });
      it('displays a message', function () {
        expect(result.messages).toEqual(['Added 2 imports']);
      });
    });
    describe('when adding multiple imports belonging to the same module', function () {
      beforeEach(function () {
        text = 'foo; bar;';
        resolvedImports = {
          foo: {
            importPath: './star/foo',
            isNamedExport: true
          },
          bar: {
            importPath: './star/foo',
            isNamedExport: true
          }
        };
      });
      it('adds imports', function () {
        expect(subject()).toEqual("\nimport { bar, foo } from './star/foo';\n\nfoo; bar;\n        ".trim());
      });
      it('displays a message', function () {
        expect(result.messages).toEqual(['Added 2 imports']);
      });
    });
    describe('when adding one import with additional data', function () {
      beforeEach(function () {
        text = 'foo';
        existingFiles = ['./star/foo.js'];
        resolvedImports = {
          foo: {
            importPath: './star/foo',
            isNamedExport: false
          }
        };
      });
      it('adds import based on variable name and import path', function () {
        expect(subject()).toEqual("\nimport foo from './star/foo';\n\nfoo\n        ".trim());
      });
      it('displays a message', function () {
        subject();
        expect(result.messages).toEqual(['Added import for `foo`']);
      });
      describe('when the resolved import exists also as a named', function () {
        beforeEach(function () {
          _readFile.default.mockImplementation(function () {
            return Promise.resolve("\n            export { foo };\n            export default function() {};\n          ");
          });
        });
        it('adds import based on resolved data provided', function () {
          expect(subject()).toEqual("\nimport foo from './star/foo';\n\nfoo\n          ".trim());
        });
      });
    });
  });
  describe('#fixImports', function () {
    var subject;
    var result;
    beforeEach(function () {
      subject = function subject() {
        setup();
        var error;
        var done = false;
        new _Importer.default(text.split('\n'), pathToCurrentFile, process.cwd()).fixImports().then(function (promiseResult) {
          result = promiseResult;
          done = true;
        }).catch(function (promiseError) {
          error = promiseError;
          done = true;
        });

        _deasync.default.loopWhile(function () {
          return !done;
        });

        if (error) {
          throw new Error(error.stack);
        }

        return result.fileContent;
      };
    });
    describe('when no undefined variables exist', function () {
      beforeEach(function () {
        text = "\nconst foo = require('foo');\n\nfoo();\n        ".trim();
      });
      it('leaves the buffer unchanged', function () {
        expect(subject()).toEqual(text);
      });
      it('displays no message', function () {
        subject();
        expect(result.messages).toEqual([]);
      });
    });
    describe('with a namespaced import', function () {
      beforeEach(function () {
        text = "\nimport * as foo from 'foo';\n\nfoo.bar();\n        ".trim();
      });
      it('leaves the buffer unchanged', function () {
        expect(subject()).toEqual(text);
      });
      it('displays no message', function () {
        subject();
        expect(result.messages).toEqual([]);
      });
    });
    describe('when the file can not be parsed', function () {
      beforeEach(function () {
        text = "\nreturn if sd([\n        ".trim();
      });
      it('leaves the buffer unchanged', function () {
        expect(subject()).toEqual(text);
      });
      it('displays an error message', function () {
        subject();
        expect(result.messages).toEqual(["SyntaxError: 'return' outside of function (1:0)"]);
      });
    });
    describe('when one undefined variable exists', function () {
      beforeEach(function () {
        existingFiles = ['bar/foo.jsx'];
        text = 'foo();';
      });
      it('imports that variable', function () {
        expect(subject()).toEqual("\nimport foo from './bar/foo';\n\nfoo();\n        ".trim());
      });
      it('displays a message', function () {
        subject();
        expect(result.messages).toEqual(["Imported foo from './bar/foo'"]);
      });
      describe('when there is whitespace at the top', function () {
        beforeEach(function () {
          text = "\n\nfoo();";
        });
        it('puts imports at the top', function () {
          expect(subject()).toEqual("\nimport foo from './bar/foo';\n\nfoo();\n          ".trim());
        });
      });
      describe('when that variable is a global', function () {
        beforeEach(function () {
          configuration.globals = ['foo'];
        });
        it('does not import anything', function () {
          expect(subject()).toEqual(text);
        });
      });
      describe('when that import already exists as a side-effect import', function () {
        beforeEach(function () {
          text = "\nimport './bar/foo';\n\nfoo();\n          ".trim();
        });
        it('changes the import', function () {
          expect(subject()).toEqual("\nimport foo from './bar/foo';\n\nfoo();\n          ".trim());
        });
        it('displays a message', function () {
          subject();
          expect(result.messages).toEqual(["Imported foo from './bar/foo'"]);
        });
      });
    });
    describe('with a module exporting types and names', function () {
      beforeEach(function () {
        existingFiles = ['star/foo.js'];

        _readFile.default.mockImplementation(function () {
          return Promise.resolve("\n          export default function() {};\n          export { bar };\n          export type Baz = {};\n          export type Faz = {};\n        ");
        });
      });
      describe('when one undefined type exists', function () {
        beforeEach(function () {
          text = 'Baz';
        });
        it('imports that type', function () {
          expect(subject()).toEqual("\nimport type { Baz } from './star/foo';\n\nBaz\n          ".trim());
        });
        it('displays a message', function () {
          subject();
          expect(result.messages).toEqual(["Imported { Baz } from './star/foo'"]);
        });
      });
      describe('when a type import is set and undefined variables exists', function () {
        beforeEach(function () {
          text = "\nimport type { Baz } from './star/foo';\n\nbar: Baz;\nfoo();\n          ".trim();
        });
        it('moves the type prefix inside brackets and adds the named and default imports', function () {
          expect(subject()).toEqual("\nimport foo, { type Baz, bar } from './star/foo';\n\nbar: Baz;\nfoo();\n          ".trim());
        });
      });
    });
    describe('when there is one `moduleSideEffectImports`', function () {
      beforeEach(function () {
        existingFiles = [];
        text = 'foo();';

        configuration.moduleSideEffectImports = function () {
          return ['surstromming'];
        };
      });
      it('imports those modules', function () {
        expect(subject()).toEqual("\nimport 'surstromming';\n\nfoo();\n        ".trim());
      });
      it('displays a message', function () {
        subject();
        expect(result.messages).toEqual(["Imported 'surstromming'"]);
      });
      describe('when that import is already in the list', function () {
        beforeEach(function () {
          text = "\nimport 'surstromming';\n\nfoo();\n          ".trim();
        });
        it('leaves the buffer untouched', function () {
          expect(subject()).toEqual(text);
        });
        it('has no message', function () {
          subject();
          expect(result.messages).toEqual([]);
        });
      });
    });
    describe('when there are multiple `moduleSideEffectImports`', function () {
      beforeEach(function () {
        existingFiles = [];
        text = 'foo();';

        configuration.moduleSideEffectImports = function () {
          return ['surstromming', 'pitepalt'];
        };
      });
      it('imports those modules', function () {
        expect(subject()).toEqual("\nimport 'pitepalt';\nimport 'surstromming';\n\nfoo();\n        ".trim());
      });
      it('displays a message', function () {
        subject();
        expect(result.messages).toEqual(['Added 2 imports']);
      });
    });
    describe('when multiple undefined variables exist', function () {
      beforeEach(function () {
        existingFiles = ['bar/foo.jsx', 'bar.js'];
        text = 'var a = foo + bar;';
      });
      it('imports all variables', function () {
        expect(subject()).toEqual("\nimport bar from './bar';\nimport foo from './bar/foo';\n\nvar a = foo + bar;\n        ".trim());
      });
      it('displays a message', function () {
        subject();
        expect(result.messages).toEqual(['Added 2 imports']);
      });
    });
    describe('when undefined variables are used multiple times', function () {
      beforeEach(function () {
        existingFiles = ['bar/foo.jsx', 'bar.js'];
        text = "\nvar a = foo + bar;\nvar b = bar + foo;\n        ".trim();
      });
      it('imports all variables', function () {
        expect(subject()).toEqual("\nimport bar from './bar';\nimport foo from './bar/foo';\n\nvar a = foo + bar;\nvar b = bar + foo;\n        ".trim());
      });
      it('displays a message with the right count', function () {
        subject();
        expect(result.messages).toEqual(['Added 2 imports']);
      });
    });
    describe('when a React component is not imported', function () {
      beforeEach(function () {
        packageDependencies = ['react'];
        existingFiles = ['bar/foo.jsx'];
        text = "\nimport React from 'react';\n\nconst foo = <Foo/>;\n        ".trim();
      });
      it('imports that component', function () {
        expect(subject()).toEqual("\nimport React from 'react';\n\nimport Foo from './bar/foo';\n\nconst foo = <Foo/>;\n        ".trim());
      });
      it('displays a message', function () {
        subject();
        expect(result.messages).toEqual(["Imported Foo from './bar/foo'"]);
      });
    });
    describe('when a React component is already imported', function () {
      beforeEach(function () {
        packageDependencies = ['react'];
        text = "\nimport React from 'react';\n\nimport Foo from 'bar/foo';\n\nconst foo = <Foo/>;\n        ".trim();
      });
      it('does not remove any imports', function () {
        expect(subject()).toEqual(text);
      });
      it('does not display any message', function () {
        subject();
        expect(result.messages).toEqual([]);
      });
    });
    describe('when an implicit React import is missing', function () {
      beforeEach(function () {
        text = 'var a = <span/>;';
      });
      describe('when react is not available', function () {
        it('leaves the buffer unchanged', function () {
          expect(subject()).toEqual(text);
        });
      });
      describe('when react is available', function () {
        beforeEach(function () {
          packageDependencies = ['react'];
        });
        it('imports React', function () {
          expect(subject()).toEqual("\nimport React from 'react';\n\nvar a = <span/>;\n          ".trim());
        });
        it('displays a message', function () {
          subject();
          expect(result.messages).toEqual(["Imported React from 'react'"]);
        });
      });
    });
    describe('when one unused import exists', function () {
      beforeEach(function () {
        text = "\nimport foo from 'bar/foo';\nimport zar from 'foo/zar';\n\nzar\n        ".trim();
      });
      it('removes that import', function () {
        expect(subject()).toEqual("\nimport zar from 'foo/zar';\n\nzar\n        ".trim());
      });
      it('displays a message', function () {
        subject();
        expect(result.messages).toEqual(['Removed `foo`.']);
      });
      describe('when that import is the last one', function () {
        beforeEach(function () {
          text = "\nimport foo from 'bar/foo';\n\nbar\n          ".trim();
        });
        it('removes that import and leaves no whitespace', function () {
          expect(subject()).toEqual("\nbar\n          ".trim());
        });
        describe('and there is a comment above', function () {
          beforeEach(function () {
            text = "\n// I'm a comment\nimport foo from 'bar/foo';\n\nbar\n            ".trim();
          });
          it('removes that import and leaves no whitespace', function () {
            expect(subject()).toEqual("\n// I'm a comment\nbar\n            ".trim());
          });
          describe('with whitespace after the comment', function () {
            beforeEach(function () {
              text = "\n// I'm a comment\n\nimport foo from 'bar/foo';\n\nbar\n              ".trim();
            });
            it('removes that import and leaves one newline', function () {
              expect(subject()).toEqual("\n// I'm a comment\n\nbar\n              ".trim());
            });
          });
        });
        describe('and there is no previous whitespace', function () {
          beforeEach(function () {
            text = "\nimport foo from 'bar/foo';\nbar\n            ".trim();
          });
          it('removes that import and leaves no whitespace', function () {
            expect(subject()).toEqual("\nbar\n            ".trim());
          });
        });
      });
    });
    describe('when the file consists of one line only', function () {
      describe('and that line is an import', function () {
        beforeEach(function () {
          text = "import foo from 'bar/foo';";
        });
        it('removes that import and leaves no whitespace', function () {
          expect(subject()).toEqual('');
        });
        it('displays a message', function () {
          subject();
          expect(result.messages).toEqual(['Removed `foo`.']);
        });
      });
      describe('and that line is not an import', function () {
        beforeEach(function () {
          text = 'const a = <span/>;';
        });
        it('leaves the file intact', function () {
          expect(subject()).toEqual(text);
        });
        it('does not tell you it removed `a`', function () {
          subject();
          expect(result.messages).toEqual([]);
        });
      });
    });
    describe('when multiple unused imports exist', function () {
      beforeEach(function () {
        text = "\nimport bar from 'foo/bar';\nimport baz from 'bar/baz';\nimport foo from 'bar/foo';\n\nbaz\n        ".trim();
      });
      it('removes all unused imports', function () {
        expect(subject()).toEqual("\nimport baz from 'bar/baz';\n\nbaz\n        ".trim());
      });
      it('displays a message', function () {
        subject();
        expect(result.messages).toEqual(['Removed 2 imports.']);
      });
    });
    describe('when an unused import and an undefined import exists', function () {
      beforeEach(function () {
        existingFiles = ['bar/foo.jsx'];
        text = "\nimport bar from 'foo/bar';\n\nfoo\n        ".trim();
      });
      it('removes the unused import and adds the missing one', function () {
        expect(subject()).toEqual("\nimport foo from './bar/foo';\n\nfoo\n        ".trim());
      });
      it('displays a message', function () {
        subject();
        expect(result.messages).toEqual(["Imported foo from './bar/foo'. Removed `bar`."]);
      });
    });
    describe('when a named import has an unused variable', function () {
      beforeEach(function () {
        text = "\nimport { bar, foo } from 'baz';\n\nbar\n        ".trim();
      });
      it('removes that variable from the named imports list', function () {
        expect(subject()).toEqual("\nimport { bar } from 'baz';\n\nbar\n        ".trim());
      });
      it('displays a message', function () {
        subject();
        expect(result.messages).toEqual(['Removed `foo`.']);
      });
    });
    describe('when the last import is removed from a named import', function () {
      beforeEach(function () {
        text = "\nimport bar from 'bar';\nimport { foo } from 'baz';\n\nbar\n        ".trim();
      });
      it('removes the whole import', function () {
        expect(subject()).toEqual("\nimport bar from 'bar';\n\nbar\n        ".trim());
      });
    });
    describe('when an unused variable that shares its name with an import exists', function () {
      beforeEach(function () {
        text = "\nimport uuid from 'uuid';\n\nfunction bar() {\n  return uuid.v4();\n}\n\nexport default function foo() {\n  const things = {\n    uuid: bar(),\n    henric: 'is cool',\n  };\n\n  const { uuid, henric } = things;\n  return henric;\n}\n        ".trim();
      });
      it('does not remove the import', function () {
        expect(subject()).toEqual(text);
      });
      it('does not display any message', function () {
        subject();
        expect(result.messages).toEqual([]);
      });
    });
  });
  describe('#rewriteImports', function () {
    var subject;
    beforeEach(function () {
      existingFiles = ['baz.jsx'];
      configuration.namedExports = {
        bar: ['foo']
      };
      packageDependencies = ['bar'];
      pathToCurrentFile = 'bilbo/frodo.js';

      subject = function subject() {
        setup();
        var error;
        var result;
        var done = false;
        new _Importer.default(text.split('\n'), pathToCurrentFile, process.cwd()).rewriteImports().then(function (promiseResult) {
          result = promiseResult;
          done = true;
        }).catch(function (promiseError) {
          error = promiseError;
          done = true;
        });

        _deasync.default.loopWhile(function () {
          return !done;
        });

        if (error) {
          throw new Error(error.stack);
        }

        return result.fileContent;
      };
    });
    describe('when imports exist', function () {
      beforeEach(function () {
        text = "\nimport baz from '../baz';\nimport bar, { foo } from 'bar';\n\nbar\n        ".trim();
      });
      describe('and we are not changing anything in config', function () {
        it('only sorts and groups imports', function () {
          expect(subject()).toEqual("\nimport bar, { foo } from 'bar';\n\nimport baz from '../baz';\n\nbar\n          ".trim());
        });
      });
      describe('and `groupImports` is false', function () {
        beforeEach(function () {
          configuration.groupImports = false;
        });
        it('sorts imports', function () {
          expect(subject()).toEqual("\nimport bar, { foo } from 'bar';\nimport baz from '../baz';\n\nbar\n          ".trim());
        });
      });
      describe('and we are switching declarationKeyword to `const`', function () {
        beforeEach(function () {
          configuration.declarationKeyword = 'const';
        });
        it('groups, sorts, and changes imports to use `const`', function () {
          expect(subject()).toEqual("\nconst bar = require('bar');\nconst { foo } = require('bar');\n\nconst baz = require('../baz');\n\nbar\n          ".trim());
        });
      });
    });
    describe('when imports use a mix of relative and normal paths', function () {
      beforeEach(function () {
        text = "\nimport bar, { foo } from 'bar';\nimport baz from '../baz';\n\nbar\n        ".trim();
      });
      describe('and we are turning relative paths off', function () {
        beforeEach(function () {
          configuration.useRelativePaths = false;
        });
        it('sorts, groups, and changes to absolute paths', function () {
          expect(subject()).toEqual("\nimport bar, { foo } from 'bar';\n\nimport baz from 'baz';\n\nbar\n          ".trim());
        });
      });
    });
    describe('when imports use normal paths', function () {
      beforeEach(function () {
        text = "\nimport bar, { foo } from 'bar';\nimport baz from 'baz';\n\nbar\n        ".trim();
      });
      describe('and we are turning relative paths on', function () {
        beforeEach(function () {
          configuration.useRelativePaths = true;
        });
        it('sorts, groups, and changes to relative paths', function () {
          expect(subject()).toEqual("\nimport bar, { foo } from 'bar';\n\nimport baz from '../baz';\n\nbar\n          ".trim());
        });
      });
    });
    describe('when an import is of the side-effect type', function () {
      describe('and is by itself', function () {
        beforeEach(function () {
          text = "\nimport 'bar.html';\n\nbar\n          ".trim();
        });
        it('is passed through unchanged', function () {
          expect(subject()).toEqual("\nimport 'bar.html';\n\nbar\n          ".trim());
        });
      });
      describe('and others are present', function () {
        beforeEach(function () {
          text = "\nimport bar, { foo } from 'bar';\nimport baz from 'baz';\nimport 'bar.html';\n\nbar\n          ".trim();
        });
        it('is passed through unchanged and sorted to the top', function () {
          expect(subject()).toEqual("\nimport 'bar.html';\n\nimport bar, { foo } from 'bar';\n\nimport baz from '../baz';\n\nbar\n          ".trim());
        });
      });
    });
  });
  describe('#goto', function () {
    var subject;
    var result;
    beforeEach(function () {
      subject = function subject() {
        setup();
        var error;
        var done = false;
        new _Importer.default(text.split('\n'), pathToCurrentFile, process.cwd()).goto(word).then(function (promiseResult) {
          result = promiseResult;
          done = true;
        }).catch(function (promiseError) {
          error = promiseError;
          done = true;
        });

        _deasync.default.loopWhile(function () {
          return !done;
        });

        if (error) {
          throw new Error(error.stack);
        }

        return result.goto;
      };
    });
    describe('with a variable name that will resolve', function () {
      beforeEach(function () {
        existingFiles = ['bar/foo.jsx'];
      });
      it('opens the file', function () {
        expect(subject()).toEqual(_path.default.join(process.cwd(), 'bar/foo.jsx'));
      });
      it('does not show a message', function () {
        subject();
        expect(result.messages).toEqual([]);
      });
    });
    describe('with a variable name that will not resolve', function () {
      beforeEach(function () {
        existingFiles = ['bar/goo.jsx'];
      });
      it('opens nothing', function () {
        expect(subject()).toBeUndefined();
      });
      it('shows a message', function () {
        subject();
        expect(result.messages).toEqual(['No JS module found for `foo`']);
      });
      describe('when there is a current import for the variable', function () {
        beforeEach(function () {
          text = "\nimport foo from 'some-package';\n\nfoo\n          ".trim();
        });
        describe('matching a package dependency', function () {
          beforeEach(function () {
            packageDependencies = ['some-package'];

            _requireRelative.default.resolve.mockImplementation(function () {
              return _path.default.join(process.cwd(), 'node_modules/some-package/some-package-main.jsx');
            });
          });
          it('opens the package main file', function () {
            expect(subject()).toEqual(_path.default.join(process.cwd(), 'node_modules/some-package/some-package-main.jsx'));
          });
        });
      });
    });
    describe('with a variable name that will resolve to a package dependency', function () {
      beforeEach(function () {
        packageDependencies = ['foo'];
      });
      it('opens the `main` file', function () {
        expect(subject()).toEqual(_path.default.join(process.cwd(), 'node_modules/foo/foo-main.jsx'));
      });
    });
    describe('with a variable name matching an alias', function () {
      beforeEach(function () {
        word = 'styles';
        pathToCurrentFile = '/foo/bar/current.js';
      });
      describe('to a relative resource', function () {
        beforeEach(function () {
          configuration.aliases = {
            styles: './index.scss'
          };
        });
        it('opens the file relative to the file being edited', function () {
          expect(subject()).toEqual('/foo/bar/index.scss');
        });
      });
      describe('to an absolute resource', function () {
        beforeEach(function () {
          configuration.aliases = {
            styles: 'stylez'
          };
          packageDependencies = ['stylez'];
        });
        it('opens the alias main file', function () {
          expect(subject()).toEqual(_path.default.join(process.cwd(), 'node_modules/stylez/stylez-main.jsx'));
        });
      });
    });
    describe('with a variable name that matches multiple files', function () {
      beforeEach(function () {
        existingFiles = ['car/foo.jsx', 'bar/foo.jsx'];
      });
      describe('when the variable has not been previously imported', function () {
        it('falls back to the file sorted at the top of the list', function () {
          expect(subject()).toEqual(_path.default.join(process.cwd(), 'bar/foo.jsx'));
        });
      });
      describe('when the variable has been previously imported', function () {
        describe('as a default import', function () {
          beforeEach(function () {
            text = "\nimport foo from './car/foo';\n\nfoo\n            ".trim();

            _requireRelative.default.resolve.mockImplementation(function () {
              return _path.default.join(process.cwd(), 'car/foo.jsx');
            });
          });
          it('opens the file', function () {
            expect(subject()).toEqual(_path.default.join(process.cwd(), 'car/foo.jsx'));
          });
          describe('and there are other imports', function () {
            beforeEach(function () {
              text = "\nimport bar from './foo/bar';\nimport foo from './car/foo';\nimport foobar from './bar/foobar';\n\nfoo\n              ".trim();
            });
            it('opens the file', function () {
              expect(subject()).toEqual(_path.default.join(process.cwd(), 'car/foo.jsx'));
            });
          });
        });
        describe('as an import where the path has been modified', function () {
          beforeEach(function () {
            configuration.moduleNameFormatter = function (_ref3) {
              var moduleName = _ref3.moduleName;
              return moduleName.replace(/^\.\/car\//, '');
            };

            text = "\nimport foo from 'foo';\n\nfoo\n            ".trim();
          });
          it('opens the file', function () {
            expect(subject()).toEqual(_path.default.join(process.cwd(), 'car/foo.jsx'));
          });
        });
        describe('as a named import', function () {
          beforeEach(function () {
            text = "\nimport { foo } from './car/foo';\n\nfoo\n            ".trim();
          });
          it('opens the file', function () {
            expect(subject()).toEqual(_path.default.join(process.cwd(), 'car/foo.jsx'));
          });
        });
      });
    });
  });
});