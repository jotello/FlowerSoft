"use strict";

var _ImportStatement = _interopRequireDefault(require("../ImportStatement"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

describe('ImportStatement', function () {
  describe('.hasNamedImports()', function () {
    it('is false without a default import or named imports', function () {
      var statement = new _ImportStatement.default();
      expect(statement.hasNamedImports()).toBe(false);
    });
    it('is false with a default import', function () {
      var statement = new _ImportStatement.default({
        defaultImport: 'foo'
      });
      expect(statement.hasNamedImports()).toBe(false);
    });
    it('is false when a default import is removed', function () {
      var statement = new _ImportStatement.default({
        defaultImport: 'foo'
      });
      statement.deleteVariable('foo');
      expect(statement.hasNamedImports()).toBe(false);
    });
    it('is true with named imports', function () {
      var statement = new _ImportStatement.default({
        namedImports: [{
          localName: 'foo'
        }]
      });
      expect(statement.hasNamedImports()).toBe(true);
    });
    it('is false when named imports are all removed', function () {
      var statement = new _ImportStatement.default({
        namedImports: [{
          localName: 'foo'
        }]
      });
      statement.deleteVariable('foo');
      expect(statement.hasNamedImports()).toBe(false);
    });
  });
  describe('.isParsedAndUntouched()', function () {
    it('is true initially', function () {
      var statement = new _ImportStatement.default({
        declarationKeyword: 'import',
        defaultImport: 'foo',
        hasSideEffects: false,
        originalImportString: "import foo, { bar, type baz } from './lib/foo';",
        namedImports: [{
          localName: 'bar'
        }, {
          localName: 'bar',
          isType: true
        }],
        path: './lib/foo'
      });
      expect(statement.isParsedAndUntouched()).toBe(true);
    });
    it('is false when a default import is deleted from a parsed statement', function () {
      var statement = new _ImportStatement.default({
        declarationKeyword: 'import',
        defaultImport: 'foo',
        hasSideEffects: false,
        originalImportString: "import foo, { bar, type baz } from './lib/foo';",
        namedImports: [{
          localName: 'bar'
        }, {
          localName: 'bar',
          isType: true
        }],
        path: './lib/foo'
      });
      statement.deleteVariable('foo');
      expect(statement.isParsedAndUntouched()).toBe(false);
    });
    it('is false when a named import is deleted from a parsed statement', function () {
      var statement = new _ImportStatement.default({
        declarationKeyword: 'import',
        defaultImport: 'foo',
        hasSideEffects: false,
        originalImportString: "import foo, { bar, type baz } from './lib/foo';",
        namedImports: [{
          localName: 'bar'
        }, {
          localName: 'bar',
          isType: true
        }],
        path: './lib/foo'
      });
      statement.deleteVariable('bar');
      expect(statement.isParsedAndUntouched()).toBe(false);
    });
    it('is true when nothing is deleted from a parsed statement', function () {
      var statement = new _ImportStatement.default({
        declarationKeyword: 'import',
        defaultImport: 'foo',
        hasSideEffects: false,
        originalImportString: "import foo, { bar, type baz } from './lib/foo';",
        namedImports: [{
          localName: 'bar'
        }, {
          localName: 'bar',
          isType: true
        }],
        path: './lib/foo'
      });
      statement.deleteVariable('somethingElse');
      expect(statement.isParsedAndUntouched()).toBe(true);
    });
  });
  describe('.isEmpty()', function () {
    it('is true without a default import or named imports', function () {
      var statement = new _ImportStatement.default();
      expect(statement.isEmpty()).toBe(true);
    });
    it('is false with a default import', function () {
      var statement = new _ImportStatement.default({
        defaultImport: 'foo'
      });
      expect(statement.isEmpty()).toBe(false);
    });
    it('is true when default import is removed', function () {
      var statement = new _ImportStatement.default({
        defaultImport: 'foo'
      });
      statement.deleteVariable('foo');
      expect(statement.isEmpty()).toBe(true);
    });
    it('is false with named imports', function () {
      var statement = new _ImportStatement.default({
        namedImports: [{
          localName: 'foo'
        }]
      });
      expect(statement.isEmpty()).toBe(false);
    });
    it('is true when all named imports are removed', function () {
      var statement = new _ImportStatement.default({
        namedImports: [{
          localName: 'foo'
        }]
      });
      statement.deleteVariable('foo');
      expect(statement.isEmpty()).toBe(true);
    });
    it('is true with an empty array of named imports', function () {
      var statement = new _ImportStatement.default({
        namedImports: []
      });
      expect(statement.isEmpty()).toBe(true);
    });
  });
  describe('.variables()', function () {
    it('is an empty array without a default or named imports', function () {
      var statement = new _ImportStatement.default();
      expect(statement.variables()).toEqual([]);
    });
    it('has the default import', function () {
      var statement = new _ImportStatement.default({
        defaultImport: 'foo'
      });
      expect(statement.variables()).toEqual(['foo']);
    });
    it('has named imports', function () {
      var statement = new _ImportStatement.default({
        namedImports: [{
          localName: 'foo'
        }, {
          localName: 'bar'
        }, {
          localName: 'baz',
          isType: true
        }]
      });
      expect(statement.variables()).toEqual(['foo', 'bar', 'baz']);
    });
    it('has default and named imports', function () {
      var statement = new _ImportStatement.default({
        defaultImport: 'foo',
        namedImports: [{
          localName: 'bar'
        }, {
          localName: 'baz',
          isType: true
        }]
      });
      expect(statement.variables()).toEqual(['foo', 'bar', 'baz']);
    });
  });
  describe('.merge()', function () {
    it('uses the existing default import without a new default import', function () {
      var existing = new _ImportStatement.default({
        defaultImport: 'foo'
      });
      var newStatement = new _ImportStatement.default();
      existing.merge(newStatement);
      expect(existing.defaultImport).toEqual('foo');
    });
    it('uses the new default import without an existing default import', function () {
      var existing = new _ImportStatement.default();
      var newStatement = new _ImportStatement.default({
        defaultImport: 'foo'
      });
      existing.merge(newStatement);
      expect(existing.defaultImport).toEqual('foo');
    });
    it('uses the new default import when an existing and new one exist', function () {
      var existing = new _ImportStatement.default({
        defaultImport: 'foo'
      });
      var newStatement = new _ImportStatement.default({
        defaultImport: 'bar'
      });
      existing.merge(newStatement);
      expect(existing.defaultImport).toEqual('bar');
    });
    it('uses the existing named imports without a new named imports', function () {
      var existing = new _ImportStatement.default({
        namedImports: [{
          localName: 'foo'
        }]
      });
      var newStatement = new _ImportStatement.default();
      existing.merge(newStatement);
      expect(existing.namedImports).toEqual([{
        localName: 'foo'
      }]);
    });
    it('uses the new named imports without existing named imports', function () {
      var existing = new _ImportStatement.default();
      var newStatement = new _ImportStatement.default({
        namedImports: [{
          localName: 'foo'
        }]
      });
      existing.merge(newStatement);
      expect(existing.namedImports).toEqual([{
        localName: 'foo'
      }]);
    });
    it('merges the named imports when both existing and new ones exist', function () {
      var existing = new _ImportStatement.default({
        namedImports: [{
          localName: 'foo'
        }]
      });
      var newStatement = new _ImportStatement.default({
        namedImports: [{
          localName: 'bar',
          isType: true
        }]
      });
      existing.merge(newStatement);
      expect(existing.namedImports).toEqual([{
        localName: 'bar',
        isType: true
      }, {
        localName: 'foo'
      }]);
    });
    it('handles the inclusion of non-type named imports into type-only imports', function () {
      var existing = new _ImportStatement.default({
        namedImports: [{
          localName: 'foo',
          isType: true
        }],
        areOnlyTypes: true
      });
      var newStatement = new _ImportStatement.default({
        namedImports: [{
          localName: 'bar'
        }]
      });
      existing.merge(newStatement);
      expect(existing.areOnlyTypes).toBeFalsy();
      expect(existing.namedImports).toEqual([{
        localName: 'bar'
      }, {
        localName: 'foo',
        isType: true
      }]);
    });
    it('merges the named imports when both existing and new ones exist', function () {
      var existing = new _ImportStatement.default({
        namedImports: [{
          localName: 'foo'
        }]
      });
      var newStatement = new _ImportStatement.default({
        namedImports: [{
          localName: 'bar',
          isType: true
        }]
      });
      existing.merge(newStatement);
      expect(existing.namedImports).toEqual([{
        localName: 'bar',
        isType: true
      }, {
        localName: 'foo'
      }]);
    });
    it('does not duplicate named imports', function () {
      var existing = new _ImportStatement.default({
        namedImports: [{
          localName: 'foo'
        }]
      });
      var newStatement = new _ImportStatement.default({
        namedImports: [{
          localName: 'foo',
          isType: true
        }]
      });
      existing.merge(newStatement);
      expect(existing.namedImports).toEqual([{
        localName: 'foo'
      }]);
    });
  });
  describe('.toImportStrings()', function () {
    describe('with the "import" declaration keyword', function () {
      it('is ok with a default import', function () {
        var statement = new _ImportStatement.default({
          declarationKeyword: 'import',
          defaultImport: 'foo',
          path: './lib/foo'
        });
        expect(statement.toImportStrings(80, '  ')).toEqual(["import foo from './lib/foo';"]);
      });
      it('is ok with a default import and an importFunction', function () {
        var statement = new _ImportStatement.default({
          declarationKeyword: 'import',
          defaultImport: 'foo',
          path: './lib/foo',
          importFunction: 'myCustomRequire'
        });
        expect(statement.toImportStrings(80, '  ')).toEqual(["import foo from './lib/foo';"]);
      });
      it('is ok with a side-effect import', function () {
        var statement = new _ImportStatement.default({
          declarationKeyword: 'import',
          hasSideEffects: true,
          path: './lib/foo'
        });
        expect(statement.toImportStrings(80, '  ')).toEqual(["import './lib/foo';"]);
      });
      it('wraps long imports', function () {
        var defaultImport = 'ReallyReallyReallyReallyLong';
        var path = 'also_very_long_for_some_reason';
        var statement = new _ImportStatement.default({
          declarationKeyword: 'import',
          defaultImport: defaultImport,
          path: path
        });
        expect(statement.toImportStrings(50, '  ')).toEqual(["import ".concat(defaultImport, " from\n  '").concat(path, "';")]);
      });
      it('uses the provided tab when wrapping', function () {
        var defaultImport = 'ReallyReallyReallyReallyLong';
        var path = 'also_very_long_for_some_reason';
        var statement = new _ImportStatement.default({
          declarationKeyword: 'import',
          defaultImport: defaultImport,
          path: path
        });
        expect(statement.toImportStrings(50, '\t')).toEqual(["import ".concat(defaultImport, " from\n\t'").concat(path, "';")]);
      });
      it('is ok with named imports', function () {
        var statement = new _ImportStatement.default({
          declarationKeyword: 'import',
          namedImports: [{
            localName: 'foo'
          }, {
            localName: 'bar',
            isType: true
          }, {
            localName: 'baz'
          }],
          path: './lib/foo'
        });
        expect(statement.toImportStrings(80, '  ')).toEqual(["import { foo, type bar, baz } from './lib/foo';"]);
      });
      it('wraps long imports with named imports', function () {
        var path = 'also_very_long_for_some_reason';
        var statement = new _ImportStatement.default({
          declarationKeyword: 'import',
          namedImports: [{
            localName: 'foo',
            isType: true
          }, {
            localName: 'bar'
          }, {
            localName: 'baz',
            isType: true
          }, {
            localName: 'fizz'
          }, {
            localName: 'buzz'
          }],
          path: path
        });
        expect(statement.toImportStrings(50, '  ')).toEqual(["import {\n  type foo,\n  bar,\n  type baz,\n  fizz,\n  buzz,\n} from '".concat(path, "';")]);
      });
      it('avoids dangling commas if explicitly told so', function () {
        var path = 'also_very_long_for_some_reason';
        var statement = new _ImportStatement.default({
          declarationKeyword: 'import',
          namedImports: [{
            localName: 'foo',
            isType: true
          }, {
            localName: 'bar'
          }, {
            localName: 'baz',
            isType: true
          }, {
            localName: 'fizz'
          }, {
            localName: 'buzz'
          }],
          path: path,
          danglingCommas: false
        });
        expect(statement.toImportStrings(50, '  ')).toEqual(["import {\n  type foo,\n  bar,\n  type baz,\n  fizz,\n  buzz\n} from '".concat(path, "';")]);
      });
      it('is ok with default import and named imports', function () {
        var statement = new _ImportStatement.default({
          declarationKeyword: 'import',
          defaultImport: 'foo',
          namedImports: [{
            localName: 'bar'
          }, {
            localName: 'baz',
            isType: true
          }],
          path: './lib/foo'
        });
        expect(statement.toImportStrings(80, '  ')).toEqual(["import foo, { bar, type baz } from './lib/foo';"]);
      });
      it('wraps long imports with default and named imports', function () {
        var path = 'also_very_long_for_some_reason';
        var statement = new _ImportStatement.default({
          declarationKeyword: 'import',
          defaultImport: 'foo',
          namedImports: [{
            localName: 'bar'
          }, {
            localName: 'baz',
            isType: true
          }, {
            localName: 'fizz'
          }, {
            localName: 'buzz',
            isType: true
          }],
          path: path
        });
        expect(statement.toImportStrings(50, '  ')).toEqual(["import foo, {\n  bar,\n  type baz,\n  fizz,\n  type buzz,\n} from '".concat(path, "';")]);
      });
      it('is ok with only type named imports', function () {
        var statement = new _ImportStatement.default({
          declarationKeyword: 'import',
          namedImports: [{
            localName: 'foo',
            isType: true
          }, {
            localName: 'bar',
            isType: true
          }],
          areOnlyTypes: true,
          path: './lib/foo'
        });
        expect(statement.toImportStrings(80, '  ')).toEqual(["import type { foo, bar } from './lib/foo';"]);
      });
      it('wraps long imports with only type named imports', function () {
        var path = 'also_very_long_for_some_reason';
        var statement = new _ImportStatement.default({
          declarationKeyword: 'import',
          namedImports: [{
            localName: 'foo',
            isType: true
          }, {
            localName: 'bar',
            isType: true
          }, {
            localName: 'baz',
            isType: true
          }],
          areOnlyTypes: true,
          path: path
        });
        expect(statement.toImportStrings(50, '  ')).toEqual(["import type {\n  foo,\n  bar,\n  baz,\n} from '".concat(path, "';")]);
      });
      it('is ok with default import and only type named imports', function () {
        var statement = new _ImportStatement.default({
          declarationKeyword: 'import',
          defaultImport: 'foo',
          namedImports: [{
            localName: 'bar',
            isType: true
          }, {
            localName: 'baz',
            isType: true
          }],
          areOnlyTypes: true,
          path: './lib/foo'
        });
        expect(statement.toImportStrings(80, '  ')).toEqual(["import foo, { type bar, type baz } from './lib/foo';"]);
      });
      it('wraps long imports with default and only type named imports', function () {
        var path = 'also_very_long_for_some_reason';
        var statement = new _ImportStatement.default({
          declarationKeyword: 'import',
          defaultImport: 'foo',
          namedImports: [{
            localName: 'bar',
            isType: true
          }, {
            localName: 'baz',
            isType: true
          }, {
            localName: 'fizz',
            isType: true
          }, {
            localName: 'buzz',
            isType: true
          }],
          areOnlyTypes: true,
          path: path
        });
        expect(statement.toImportStrings(50, '  ')).toEqual(["import foo, {\n  type bar,\n  type baz,\n  type fizz,\n  type buzz,\n} from '".concat(path, "';")]);
      });
    });
    describe('with the "const" declaration keyword', function () {
      it('is ok with a default import', function () {
        var statement = new _ImportStatement.default({
          declarationKeyword: 'const',
          defaultImport: 'foo',
          path: './lib/foo'
        });
        expect(statement.toImportStrings(80, '  ')).toEqual(["const foo = require('./lib/foo');"]);
      });
      it('is ok with a default import and an importFunction', function () {
        var statement = new _ImportStatement.default({
          declarationKeyword: 'const',
          defaultImport: 'foo',
          path: './lib/foo',
          importFunction: 'myCustomRequire'
        });
        expect(statement.toImportStrings(80, '  ')).toEqual(["const foo = myCustomRequire('./lib/foo');"]);
      });
      it('is ok with a side-effect import', function () {
        var statement = new _ImportStatement.default({
          declarationKeyword: 'const',
          hasSideEffects: true,
          path: './lib/foo'
        });
        expect(statement.toImportStrings(80, '  ')).toEqual(["require('./lib/foo');"]);
      });
      it('wraps long imports', function () {
        var defaultImport = 'ReallyReallyReallyReallyLong';
        var path = 'also_very_long_for_some_reason';
        var statement = new _ImportStatement.default({
          declarationKeyword: 'const',
          defaultImport: defaultImport,
          path: path
        });
        expect(statement.toImportStrings(50, '  ')).toEqual(["const ".concat(defaultImport, " =\n  require('").concat(path, "');")]);
      });
      it('uses the provided tab when wrapping', function () {
        var defaultImport = 'ReallyReallyReallyReallyLong';
        var path = 'also_very_long_for_some_reason';
        var statement = new _ImportStatement.default({
          declarationKeyword: 'const',
          defaultImport: defaultImport,
          path: path
        });
        expect(statement.toImportStrings(50, '\t')).toEqual(["const ".concat(defaultImport, " =\n\trequire('").concat(path, "');")]);
      });
      it('is ok with named imports', function () {
        var statement = new _ImportStatement.default({
          declarationKeyword: 'const',
          namedImports: [{
            localName: 'foo'
          }, {
            localName: 'bar'
          }],
          path: './lib/foo'
        });
        expect(statement.toImportStrings(80, '  ')).toEqual(["const { foo, bar } = require('./lib/foo');"]);
      });
      it('is ok with named imports and an importFunction', function () {
        var statement = new _ImportStatement.default({
          declarationKeyword: 'const',
          namedImports: [{
            localName: 'foo'
          }, {
            localName: 'bar'
          }],
          path: './lib/foo',
          importFunction: 'myCustomRequire'
        });
        expect(statement.toImportStrings(80, '  ')).toEqual(["const { foo, bar } = myCustomRequire('./lib/foo');"]);
      });
      it('is ok with a side-effect import and an importFunction', function () {
        var statement = new _ImportStatement.default({
          declarationKeyword: 'const',
          hasSideEffects: true,
          importFunction: 'foo',
          path: './lib/foo'
        });
        expect(statement.toImportStrings(80, '  ')).toEqual(["foo('./lib/foo');"]);
      });
      it('wraps long imports with named imports', function () {
        var path = 'also_very_long_for_some_reason';
        var statement = new _ImportStatement.default({
          declarationKeyword: 'const',
          namedImports: [{
            localName: 'foo'
          }, {
            localName: 'bar'
          }, {
            localName: 'baz'
          }, {
            localName: 'fizz'
          }, {
            localName: 'buzz'
          }],
          path: path
        });
        expect(statement.toImportStrings(50, '  ')).toEqual(["const {\n  foo,\n  bar,\n  baz,\n  fizz,\n  buzz,\n} = require('".concat(path, "');")]);
      });
      it('is ok with default import and named imports', function () {
        var statement = new _ImportStatement.default({
          declarationKeyword: 'const',
          defaultImport: 'foo',
          namedImports: [{
            localName: 'bar'
          }, {
            localName: 'baz'
          }],
          path: './lib/foo'
        });
        expect(statement.toImportStrings(80, '  ')).toEqual(["const foo = require('./lib/foo');", "const { bar, baz } = require('./lib/foo');"]);
      });
      it('is ok with default import, named imports, and an importFunction', function () {
        var statement = new _ImportStatement.default({
          declarationKeyword: 'const',
          defaultImport: 'foo',
          namedImports: [{
            localName: 'bar'
          }, {
            localName: 'baz'
          }],
          path: './lib/foo',
          importFunction: 'myCustomRequire'
        });
        expect(statement.toImportStrings(80, '  ')).toEqual(["const foo = myCustomRequire('./lib/foo');", "const { bar, baz } = myCustomRequire('./lib/foo');"]);
      });
      it('wraps long imports with default and named imports', function () {
        var path = 'also_very_long_for_some_reason';
        var statement = new _ImportStatement.default({
          declarationKeyword: 'const',
          defaultImport: 'foo',
          namedImports: [{
            localName: 'bar'
          }, {
            localName: 'baz'
          }, {
            localName: 'fizz'
          }, {
            localName: 'buzz'
          }],
          path: path
        });
        expect(statement.toImportStrings(50, '  ')).toEqual(["const foo =\n  require('".concat(path, "');"), "const {\n  bar,\n  baz,\n  fizz,\n  buzz,\n} = require('".concat(path, "');")]);
      });
    });
  });
});