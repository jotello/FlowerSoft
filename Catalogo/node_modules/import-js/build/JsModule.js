"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _Configuration = _interopRequireDefault(require("./Configuration"));

var _ImportStatement = _interopRequireDefault(require("./ImportStatement"));

var _forwardSlashes = _interopRequireDefault(require("./forwardSlashes"));

var _requireResolve = _interopRequireDefault(require("./requireResolve"));

var _resolveImportPathAndMain = _interopRequireDefault(require("./resolveImportPathAndMain"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// TODO figure out a more holistic solution than stripping node_modules
function stripNodeModules(path) {
  if (path.startsWith('node_modules/')) {
    return path.slice(13);
  }

  return path;
} // Class that represents a js module found in the file system


var JsModule =
/*#__PURE__*/
function () {
  _createClass(JsModule, null, [{
    key: "construct",

    /**
     * @param {Boolean} hasNamedExports
     * @param {Boolean} isType
     * @param {String|null} opts.makeRelativeTo a path to a different file which
     *   the resulting import path should be relative to.
     * @param {String} opts.relativeFilePath a full path to the file, relative to
     *   the project root.
     * @param {Array} opts.stripFileExtensions a list of file extensions to strip,
     *   e.g. ['.js', '.jsx']
     * @param {String} opts.variableName
     * @param {String} opts.workingDirectory
     * @return {JsModule}
     */
    value: function construct() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          hasNamedExports = _ref.hasNamedExports,
          _ref$isType = _ref.isType,
          isType = _ref$isType === void 0 ? false : _ref$isType,
          makeRelativeTo = _ref.makeRelativeTo,
          relativeFilePath = _ref.relativeFilePath,
          stripFileExtensions = _ref.stripFileExtensions,
          variableName = _ref.variableName,
          _ref$workingDirectory = _ref.workingDirectory,
          workingDirectory = _ref$workingDirectory === void 0 ? process.cwd() : _ref$workingDirectory;

      var jsModule = new JsModule();
      jsModule.filePath = relativeFilePath;
      var importPathAndMainFile = (0, _resolveImportPathAndMain.default)(jsModule.filePath, stripFileExtensions, workingDirectory);
      var importPath = importPathAndMainFile[0];
      var mainFile = importPathAndMainFile[1];

      if (!importPath) {
        return null;
      }

      if (mainFile) {
        jsModule.filePath = (0, _forwardSlashes.default)(_path.default.normalize(_path.default.join(importPath, mainFile)));
      }

      jsModule.importPath = importPath;
      jsModule.hasNamedExports = hasNamedExports;
      jsModule.isType = isType;
      jsModule.variableName = variableName;

      if (makeRelativeTo) {
        jsModule.makeRelativeTo(makeRelativeTo);
      } else {
        jsModule.importPath = jsModule.importPath.replace(/^\.\//, '');
      }

      return jsModule;
    }
  }]);

  function JsModule() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        hasNamedExports = _ref2.hasNamedExports,
        _ref2$isType = _ref2.isType,
        isType = _ref2$isType === void 0 ? false : _ref2$isType,
        importPath = _ref2.importPath,
        variableName = _ref2.variableName;

    _classCallCheck(this, JsModule);

    this.hasNamedExports = hasNamedExports;
    this.isType = isType;
    this.importPath = importPath;
    this.variableName = variableName;
  }

  _createClass(JsModule, [{
    key: "makeRelativeTo",
    value: function makeRelativeTo(makeRelativeToPath) {
      var importPath = _path.default.relative(_path.default.dirname(makeRelativeToPath), this.importPath);

      importPath = (0, _forwardSlashes.default)(importPath); // `path.relative` will not add "./" automatically

      if (!importPath.startsWith('.')) {
        importPath = "./".concat(importPath);
      }

      this.importPath = importPath;
    }
  }, {
    key: "resolvedFilePath",
    value: function resolvedFilePath(pathToCurrentFile) {
      var workingDirectory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.cwd();

      if (this.filePath) {
        return this.filePath;
      } // There is no filePath. This likely means that we are working with an
      // alias, so we want to expand it to a full path if we can.


      if (this.importPath.startsWith('.')) {
        // The import path in the alias starts with a ".", which means that it is
        // relative to the current file. In order to open this file, we need to
        // expand it to a full path.
        return (0, _forwardSlashes.default)(_path.default.resolve(_path.default.dirname(pathToCurrentFile), this.importPath));
      } // If all of the above fails to find a path, we fall back to using
      // require.resolve() to find the file path.


      var unresolved = _path.default.join(workingDirectory, this.importPath);

      var resolved = (0, _requireResolve.default)(unresolved);

      if (unresolved !== resolved) {
        // We found a location for the import
        return resolved;
      } // as a last resort, assume it's a package dependency


      return (0, _requireResolve.default)(_path.default.join(workingDirectory, 'node_modules', this.importPath));
    }
  }, {
    key: "_getNamedImports",
    value: function _getNamedImports() {
      if (!this.hasNamedExports) {
        return [];
      }

      return [{
        localName: this.variableName,
        isType: this.isType
      }];
    }
  }, {
    key: "_getDefaultImport",
    value: function _getDefaultImport() {
      if (this.hasNamedExports) {
        return '';
      }

      return this.variableName;
    }
  }, {
    key: "toImportStatement",
    value: function toImportStatement(config) {
      var namedImports = this._getNamedImports();

      var defaultImport = this._getDefaultImport(); // TODO figure out a more holistic solution than stripping node_modules


      var pathToImportedModule = stripNodeModules(this.resolvedFilePath(config.pathToCurrentFile, config.workingDirectory));
      return new _ImportStatement.default({
        declarationKeyword: config.get('declarationKeyword', {
          pathToImportedModule: pathToImportedModule
        }),
        defaultImport: defaultImport,
        hasSideEffects: false,
        importFunction: config.get('importFunction', {
          pathToImportedModule: pathToImportedModule
        }),
        namedImports: namedImports,
        areOnlyTypes: this.isType,
        danglingCommas: config.get('danglingCommas'),
        path: config.get('moduleNameFormatter', {
          pathToImportedModule: pathToImportedModule,
          // TODO figure out a more holistic solution than stripping node_modules
          moduleName: stripNodeModules(this.importPath)
        })
      });
    }
  }]);

  return JsModule;
}();

exports.default = JsModule;