"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _crypto = _interopRequireDefault(require("crypto"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _has = _interopRequireDefault(require("lodash/has"));

var _globals = _interopRequireDefault(require("globals"));

var _semver = _interopRequireDefault(require("semver"));

var _FileUtils = _interopRequireDefault(require("./FileUtils"));

var _JsModule = _interopRequireDefault(require("./JsModule"));

var _findPackageDependencies = _interopRequireDefault(require("./findPackageDependencies"));

var _meteorEnvironment = _interopRequireDefault(require("./environments/meteorEnvironment"));

var _nodeEnvironment = _interopRequireDefault(require("./environments/nodeEnvironment"));

var _normalizePath = _interopRequireDefault(require("./normalizePath"));

var _version = _interopRequireDefault(require("./version"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var JSON_CONFIG_FILE = '.importjs.json';
var JS_CONFIG_FILE = '.importjs.js';

function findGlobalsFromEnvironments(environments) {
  var result = Object.keys(_globals.default.builtin);
  environments.forEach(function (environment) {
    var envGlobals = _globals.default[environment];

    if (!envGlobals) {
      return;
    }

    result.push.apply(result, _toConsumableArray(Object.keys(envGlobals)));
  });
  return result;
}

var DEFAULT_CONFIG = {
  aliases: {},
  declarationKeyword: 'import',
  cacheLocation: function cacheLocation(_ref) {
    var config = _ref.config;

    var hash = _crypto.default.createHash('md5').update("".concat(config.workingDirectory, "-v4")).digest('hex');

    return _path.default.join(_os.default.tmpdir(), "import-js-".concat(hash, ".db"));
  },
  coreModules: [],
  namedExports: {},
  environments: [],
  excludes: [],
  globals: function globals(_ref2) {
    var config = _ref2.config;
    return findGlobalsFromEnvironments(config.get('environments'));
  },
  groupImports: true,
  ignorePackagePrefixes: [],
  importDevDependencies: false,
  importFunction: 'require',
  importStatementFormatter: function importStatementFormatter(_ref3) {
    var importStatement = _ref3.importStatement;
    return importStatement;
  },
  logLevel: 'info',
  maxLineLength: 80,
  minimumVersion: '0.0.0',
  moduleNameFormatter: function moduleNameFormatter(_ref4) {
    var moduleName = _ref4.moduleName;
    return moduleName;
  },
  moduleSideEffectImports: function moduleSideEffectImports() {
    return [];
  },
  sortImports: true,
  emptyLineBetweenGroups: true,
  stripFileExtensions: ['.js', '.jsx', '.ts', '.tsx'],
  danglingCommas: true,
  tab: '  ',
  useRelativePaths: true,
  packageDependencies: function packageDependencies(_ref5) {
    var config = _ref5.config;
    return (0, _findPackageDependencies.default)(config.workingDirectory, config.get('importDevDependencies'));
  },
  // Default configuration options, and options inherited from environment
  // configuration are overridden if they appear in user config. Some options,
  // however, get merged with the parent configuration. This list specifies which
  // ones are merged.
  mergableOptions: {
    aliases: true,
    coreModules: true,
    namedExports: true,
    globals: true
  }
};
var KNOWN_CONFIGURATION_OPTIONS = ['aliases', 'cacheLocation', 'coreModules', 'declarationKeyword', 'environments', 'excludes', 'globals', 'groupImports', 'ignorePackagePrefixes', 'importDevDependencies', 'importFunction', 'importStatementFormatter', 'logLevel', 'maxLineLength', 'minimumVersion', 'moduleNameFormatter', 'moduleSideEffectImports', 'namedExports', 'sortImports', 'stripFileExtensions', 'tab', 'useRelativePaths', 'mergableOptions', 'danglingCommas', 'emptyLineBetweenGroups'];
var DEPRECATED_CONFIGURATION_OPTIONS = [];
var ENVIRONMENTS = {
  node: _nodeEnvironment.default,
  meteor: _meteorEnvironment.default
};

function checkForUnknownConfiguration(config) {
  var messages = [];
  Object.keys(config).forEach(function (option) {
    if (KNOWN_CONFIGURATION_OPTIONS.indexOf(option) === -1) {
      messages.push("Unknown configuration: `".concat(option, "`"));
    }
  });
  return messages;
}

function checkForDeprecatedConfiguration(config) {
  var messages = [];
  Object.keys(config).forEach(function (option) {
    if (DEPRECATED_CONFIGURATION_OPTIONS.indexOf(option) !== -1) {
      messages.push("Using ".concat(option, " to configure ImportJS is deprecated and ") + 'will go away in a future version.');
    }
  });
  return messages;
}
/**
  * Checks that the current version is bigger than the `minimumVersion`
  * defined in config.
  * @throws Error if current version is less than the `minimumVersion` defined
  * in config.
  */


function checkCurrentVersion(minimumVersion) {
  if (_semver.default.gte((0, _version.default)(), minimumVersion)) {
    return;
  }

  throw Error("The configuration file for this project requires version ".concat(minimumVersion, " or newer. You are using ").concat((0, _version.default)(), "."));
}

function mergedValue(values, key, options) {
  var mergedResult;

  for (var i = 0; i < values.length; i += 1) {
    var value = values[i];

    if (typeof value === 'function') {
      value = value(options);
    } // Prevent an endless loop of mergedValue calls
    // The mergableOptions key will get merged by skipping this check


    if (key !== 'mergableOptions') {
      var mergableOptions = options.config.get('mergableOptions');

      if (mergableOptions[key] !== true) {
        // This key shouldn't be merged
        return value;
      }
    }

    if (Array.isArray(value)) {
      mergedResult = (mergedResult || []).concat(value);
    } else if (_typeof(value) === 'object') {
      mergedResult = Object.assign({}, value, mergedResult || {});
    } else {
      // Neither an object nor an array, so we just return the first value we
      // have.
      return value;
    }
  }

  return mergedResult;
} // Class that initializes configuration from a .importjs.js file


var Configuration =
/*#__PURE__*/
function () {
  function Configuration(pathToCurrentFile) {
    var _this = this;

    var workingDirectory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : process.cwd();

    _classCallCheck(this, Configuration);

    this.workingDirectory = workingDirectory;
    this.pathToCurrentFile = (0, _normalizePath.default)(pathToCurrentFile, workingDirectory);
    this.messages = [];
    this.configs = [];
    var userConfig;

    try {
      userConfig = this.loadUserConfig();
    } catch (error) {
      this.messages.push("Unable to parse configuration file. Reason:\n".concat(error.stack));
    }

    if (userConfig) {
      var _this$messages, _this$messages2;

      this.configs.push(userConfig);

      (_this$messages = this.messages).push.apply(_this$messages, _toConsumableArray(checkForUnknownConfiguration(userConfig)));

      (_this$messages2 = this.messages).push.apply(_this$messages2, _toConsumableArray(checkForDeprecatedConfiguration(userConfig))); // Add configurations for the environments specified in the user config
      // file.
      // Don't use `this.get` because the config hasn't finished initalizing.
      // Use userConfig instead since it's the only one declared


      if (typeof userConfig.environments === 'function') {
        userConfig.environments = userConfig.environments({
          config: this,
          pathToCurrentFile: this.pathToCurrentFile
        });
      }

      (userConfig.environments || []).forEach(function (environment) {
        var envConfig = ENVIRONMENTS[environment];

        if (envConfig) {
          _this.configs.push(envConfig);
        }
      });
    }

    this.configs.push(DEFAULT_CONFIG);
    checkCurrentVersion(this.get('minimumVersion'));
  }

  _createClass(Configuration, [{
    key: "get",
    value: function get(key) {
      var _ref6 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          pathToImportedModule = _ref6.pathToImportedModule,
          moduleName = _ref6.moduleName,
          importStatement = _ref6.importStatement;

      var applyingConfigs = this.configs.filter(function (config) {
        return Object.prototype.hasOwnProperty.call(config, key);
      });
      return mergedValue(applyingConfigs.map(function (config) {
        return config[key];
      }), key, {
        pathToImportedModule: pathToImportedModule,
        moduleName: moduleName,
        config: this,
        pathToCurrentFile: this.pathToCurrentFile,
        importStatement: importStatement
      });
    }
  }, {
    key: "loadUserConfig",
    value: function loadUserConfig() {
      var jsConfig = _FileUtils.default.readJsFile(_path.default.join(this.workingDirectory, JS_CONFIG_FILE));

      if (jsConfig && Object.keys(jsConfig).length === 0) {
        // If you forget to use `module.exports`, the config object will be `{}`.
        // To prevent subtle errors from happening, we surface an error message to
        // the user.
        throw new Error("Nothing exported from ".concat(JS_CONFIG_FILE, ". You need to use `module.exports` to specify what gets exported from the file."));
      }

      if (jsConfig) {
        return jsConfig;
      }

      var jsonConfig = _FileUtils.default.readJsonFile(_path.default.join(this.workingDirectory, JSON_CONFIG_FILE));

      if (jsonConfig) {
        this.messages.push('Using JSON to configure ImportJS is deprecated and will go away in a future version. Use an `.importjs.js` file instead.');
        return jsonConfig;
      }

      var globalConfig = _FileUtils.default.readJsFile(_path.default.join(_os.default.homedir(), JS_CONFIG_FILE));

      return globalConfig;
    }
  }, {
    key: "resolveAlias",
    value: function resolveAlias(variableName) {
      if (!(0, _has.default)(this.get('aliases'), variableName)) {
        return null;
      }

      var importPath = this.get('aliases')[variableName];
      importPath = importPath.path || importPath; // path may be an object

      if (this.pathToCurrentFile !== './') {
        // aliases can have dynamic `{filename}` parts
        importPath = importPath.replace(/\{filename\}/, _path.default.basename(this.pathToCurrentFile, _path.default.extname(this.pathToCurrentFile)));
      }

      return importPath;
    }
  }, {
    key: "resolveNamedExports",
    value: function resolveNamedExports(variableName) {
      var allNamedExports = this.get('namedExports');
      var importPath = Object.keys(allNamedExports).find(function (key) {
        return allNamedExports[key].indexOf(variableName) !== -1;
      });

      if (!importPath) {
        return undefined;
      }

      var jsModule = new _JsModule.default({
        importPath: importPath,
        hasNamedExports: true,
        variableName: variableName
      });
      return jsModule;
    }
  }]);

  return Configuration;
}();

exports.default = Configuration;