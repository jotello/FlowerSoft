"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _requireRelative = _interopRequireDefault(require("require-relative"));

var _CommandLineEditor = _interopRequireDefault(require("./CommandLineEditor"));

var _Configuration = _interopRequireDefault(require("./Configuration"));

var _ImportStatement = _interopRequireDefault(require("./ImportStatement"));

var _ImportStatements = _interopRequireDefault(require("./ImportStatements"));

var _JsModule = _interopRequireDefault(require("./JsModule"));

var _findCurrentImports2 = _interopRequireDefault(require("./findCurrentImports"));

var _findJsModulesFor = _interopRequireDefault(require("./findJsModulesFor"));

var _findUndefinedIdentifiers = _interopRequireDefault(require("./findUndefinedIdentifiers"));

var _findUsedIdentifiers = _interopRequireDefault(require("./findUsedIdentifiers"));

var _parse = _interopRequireDefault(require("./parse"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function fixImportsMessage(removedItems, addedItems) {
  var messageParts = [];
  var firstAdded = addedItems.values().next().value;
  var firstRemoved = removedItems.values().next().value;

  if (addedItems.size === 1 && firstAdded) {
    messageParts.push("Imported ".concat(firstAdded));
  } else if (addedItems.size) {
    messageParts.push("Added ".concat(addedItems.size, " imports"));
  }

  if (removedItems.size === 1 && firstRemoved) {
    messageParts.push("Removed `".concat(firstRemoved, "`."));
  } else if (removedItems.size) {
    messageParts.push("Removed ".concat(removedItems.size, " imports."));
  }

  if (messageParts.length === 0) {
    return undefined;
  }

  return messageParts.join('. ');
}

function findFilePathFromImports(imports, dirname, variableName) {
  // eslint-disable-next-line no-restricted-syntax
  var importStatement = imports.find(function (is) {
    return is.hasVariable(variableName);
  });

  if (!importStatement) {
    return undefined;
  }

  try {
    return _requireRelative.default.resolve(importStatement.path, dirname);
  } catch (e) {// it's expected that we can't resolve certain paths.
  }

  return undefined;
}

var Importer =
/*#__PURE__*/
function () {
  function Importer(lines, pathToCurrentFile) {
    var workingDirectory = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : process.cwd();

    _classCallCheck(this, Importer);

    this.pathToCurrentFile = pathToCurrentFile || '';
    this.editor = new _CommandLineEditor.default(lines);
    this.config = new _Configuration.default(this.pathToCurrentFile, workingDirectory);
    this.workingDirectory = workingDirectory;
    this.messages = Array.from(this.config.messages);
    this.unresolvedImports = {};

    try {
      this.ast = (0, _parse.default)(this.editor.currentFileContent(), this.pathToCurrentFile);
    } catch (e) {
      if (e instanceof SyntaxError) {
        this.message("SyntaxError: ".concat(e.message));
        this.ast = (0, _parse.default)('', '');
      } else {
        throw new Error(e);
      }
    }
  }

  _createClass(Importer, [{
    key: "results",
    value: function results() {
      return {
        messages: this.messages,
        // array
        fileContent: this.editor.currentFileContent(),
        // string
        unresolvedImports: this.unresolvedImports // object

      };
    }
    /**
     * Imports one variable
     */

  }, {
    key: "import",
    value: function _import(variableName) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        _this.findOneJsModule(variableName).then(function (jsModule) {
          if (!jsModule) {
            if (!Object.keys(_this.unresolvedImports).length) {
              _this.message("No JS module to import for `".concat(variableName, "`"));
            }

            resolve(_this.results());
            return;
          }

          var imported = jsModule.hasNamedExports ? "{ ".concat(variableName, " }") : variableName;

          _this.message("Imported ".concat(imported, " from '").concat(jsModule.importPath, "'"));

          var oldImports = _this.findCurrentImports();

          var importStatement = jsModule.toImportStatement(_this.config);
          oldImports.imports.push(importStatement);

          _this.replaceImports(oldImports.range, oldImports.imports);

          resolve(_this.results());
        }).catch(function (error) {
          reject(error);
        });
      });
    }
    /**
     * Searches for an export
     */

  }, {
    key: "search",
    value: function search(variableName) {
      var _this2 = this;

      return (0, _findJsModulesFor.default)(this.config, variableName, {
        search: true
      }).then(function (modules) {
        return {
          modules: modules,
          messages: _this2.messages
        };
      });
    }
  }, {
    key: "goto",
    value: function goto(variableName) {
      var _this3 = this;

      var _this$findCurrentImpo = this.findCurrentImports(),
          imports = _this$findCurrentImpo.imports;

      var filePath = findFilePathFromImports(imports, _path.default.dirname(this.pathToCurrentFile), variableName);

      if (filePath) {
        return Promise.resolve(_objectSpread({
          goto: filePath
        }, this.results()));
      }

      return new Promise(function (resolve, reject) {
        (0, _findJsModulesFor.default)(_this3.config, variableName).then(function (jsModules) {
          if (!jsModules.length) {
            // The current word is not mappable to one of the JS modules that we
            // found. This can happen if the user does not select one from the list.
            // We have nothing to go to, so we return early.
            _this3.message("No JS module found for `".concat(variableName, "`"));

            resolve(_this3.results());
            return;
          }

          var filePath = jsModules[0].resolvedFilePath(_this3.pathToCurrentFile, _this3.workingDirectory);

          var results = _this3.results();

          results.goto = _path.default.isAbsolute(filePath) ? filePath : _path.default.join(_this3.workingDirectory, filePath);
          resolve(results);
        }).catch(function (error) {
          reject(error);
        });
      });
    } // Removes unused imports and adds imports for undefined variables

  }, {
    key: "fixImports",
    value: function fixImports() {
      var _this4 = this;

      var undefinedVariables = (0, _findUndefinedIdentifiers.default)(this.ast, this.config.get('globals'));
      var usedVariables = (0, _findUsedIdentifiers.default)(this.ast);
      var oldImports = this.findCurrentImports();
      var newImports = oldImports.imports.clone();
      var unusedImportVariables = new Set();
      oldImports.imports.forEach(function (importStatement) {
        importStatement.variables().forEach(function (variable) {
          if (!usedVariables.has(variable)) {
            unusedImportVariables.add(variable);
          }
        });
      });
      newImports.deleteVariables(unusedImportVariables);
      var addedItems = new Set(this.injectSideEffectImports(newImports));
      return new Promise(function (resolve, reject) {
        var allPromises = [];
        undefinedVariables.forEach(function (variable) {
          allPromises.push(_this4.findOneJsModule(variable));
        });
        Promise.all(allPromises).then(function (results) {
          results.forEach(function (jsModule) {
            if (!jsModule) {
              return;
            }

            var imported = jsModule.hasNamedExports ? "{ ".concat(jsModule.variableName, " }") : jsModule.variableName;
            addedItems.add("".concat(imported, " from '").concat(jsModule.importPath, "'"));
            newImports.push(jsModule.toImportStatement(_this4.config));
          });

          _this4.replaceImports(oldImports.range, newImports);

          var message = fixImportsMessage(unusedImportVariables, addedItems);

          if (message) {
            _this4.message(message);
          }

          resolve(_this4.results());
        }).catch(function (error) {
          reject(error);
        });
      });
    }
  }, {
    key: "addImports",
    value: function addImports(imports) {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        var oldImports = _this5.findCurrentImports();

        var newImports = oldImports.imports.clone();
        var variables = Object.keys(imports);
        var promises = variables.map(function (variableName) {
          return (0, _findJsModulesFor.default)(_this5.config, variableName).then(function (jsModules) {
            var importData = imports[variableName];
            var dataIsObject = _typeof(importData) === 'object';
            var importPath = dataIsObject ? importData.importPath : importData;
            var hasNamedExports = dataIsObject ? importData.isNamedExport : undefined;
            var foundModule = jsModules.find(function (jsModule) {
              return jsModule.importPath === importPath && (hasNamedExports === undefined || jsModule.hasNamedExports === hasNamedExports);
            });

            if (foundModule) {
              newImports.push(foundModule.toImportStatement(_this5.config));
            } else {
              newImports.push(new _JsModule.default({
                importPath: importPath,
                variableName: variableName,
                hasNamedExports: hasNamedExports
              }).toImportStatement(_this5.config));
            }
          }).catch(reject);
        });
        Promise.all(promises).then(function () {
          if (variables.length === 1) {
            _this5.message("Added import for `".concat(variables[0], "`"));
          } else {
            _this5.message("Added ".concat(variables.length, " imports"));
          }

          _this5.replaceImports(oldImports.range, newImports);

          resolve(_this5.results());
        });
      });
    }
  }, {
    key: "rewriteImports",
    value: function rewriteImports() {
      var _this6 = this;

      var oldImports = this.findCurrentImports();
      var newImports = new _ImportStatements.default(this.config);
      return new Promise(function (resolve, reject) {
        var variables = [];
        var sideEffectOnlyImports = [];
        oldImports.imports.forEach(function (imp) {
          if (imp.variables().length) {
            variables.push.apply(variables, _toConsumableArray(imp.variables()));
          } else if (imp.hasSideEffects) {
            // side-effect imports don't have variable names. Tuck them away and just pass
            // them through to the end of this operation.
            sideEffectOnlyImports.push(imp);
          }
        });
        var promises = variables.map(function (variable) {
          return (0, _findJsModulesFor.default)(_this6.config, variable);
        });
        Promise.all(promises).then(function (results) {
          results.forEach(function (jsModules) {
            if (!jsModules.length) {
              return;
            }

            var variableName = jsModules[0].variableName;

            var jsModule = _this6.resolveModuleUsingCurrentImports(jsModules, variableName) || _this6.resolveOneJsModule(jsModules, variableName);

            if (!jsModule) {
              return;
            }

            newImports.push(jsModule.toImportStatement(_this6.config));
          });
          newImports.push.apply(newImports, sideEffectOnlyImports);

          _this6.replaceImports(oldImports.range, newImports);

          resolve(_this6.results());
        }).catch(function (error) {
          reject(error);
        });
      });
    }
  }, {
    key: "message",
    value: function message(str) {
      this.messages.push(str);
    }
  }, {
    key: "findOneJsModule",
    value: function findOneJsModule(variableName) {
      var _this7 = this;

      return new Promise(function (resolve, reject) {
        (0, _findJsModulesFor.default)(_this7.config, variableName).then(function (jsModules) {
          if (!jsModules.length) {
            resolve(null);
            return;
          }

          resolve(_this7.resolveOneJsModule(jsModules, variableName));
        }).catch(function (error) {
          reject(error);
        });
      });
    }
  }, {
    key: "replaceImports",
    value: function replaceImports(oldImportsRange, newImports) {
      var _this8 = this;

      var importStrings = newImports.toArray(); // Ensure that there is a blank line after the block of all imports

      if (importStrings.length && this.editor.get(oldImportsRange.end) !== '') {
        this.editor.insertBefore(oldImportsRange.end, '');
      } // Delete old imports, then add the modified list back in.


      for (var i = oldImportsRange.end - 1; i >= oldImportsRange.start; i -= 1) {
        this.editor.remove(i);
      }

      if (importStrings.length === 0 && this.editor.get(oldImportsRange.start) === '') {
        // We have no newlines to write back to the file. Clearing out potential
        // whitespace where the imports used to be leaves the file in a better
        // state.
        this.editor.remove(oldImportsRange.start);
        return;
      }

      importStrings.reverse().forEach(function (importString) {
        // We need to add each line individually because the Vim buffer will
        // convert newline characters to `~@`.
        if (importString.indexOf('\n') !== -1) {
          importString.split('\n').reverse().forEach(function (line) {
            _this8.editor.insertBefore(oldImportsRange.start, line);
          });
        } else {
          _this8.editor.insertBefore(oldImportsRange.start, importString);
        }
      });

      while (this.editor.get(0) === '') {
        this.editor.remove(0);
      }
    }
  }, {
    key: "findCurrentImports",
    value: function findCurrentImports() {
      return (0, _findCurrentImports2.default)(this.config, this.editor.currentFileContent(), this.ast);
    }
  }, {
    key: "resolveOneJsModule",
    value: function resolveOneJsModule(jsModules, variableName) {
      var _this9 = this;

      if (jsModules.length === 1) {
        var jsModule = jsModules[0];
        return jsModule;
      }

      if (!jsModules.length) {
        return undefined;
      }

      var countSeparators = function countSeparators(importPath) {
        var separators = importPath.match(/\//g);
        return separators ? separators.length : 0;
      };

      this.unresolvedImports[variableName] = jsModules.map(function (jsModule) {
        return {
          displayName: jsModule.toImportStatement(_this9.config).toImportStrings(Infinity, '  ')[0],
          importPath: jsModule.importPath,
          // backward compatibility
          data: {
            importPath: jsModule.importPath,
            filePath: jsModule.resolvedFilePath(_this9.pathToCurrentFile, _this9.workingDirectory),
            isNamedExport: jsModule.hasNamedExports
          }
        };
      }).sort(function (a, b) {
        return countSeparators(a.data.importPath) - countSeparators(b.data.importPath);
      });
      return undefined;
    }
  }, {
    key: "resolveModuleUsingCurrentImports",
    value: function resolveModuleUsingCurrentImports(jsModules, variableName) {
      var _this10 = this;

      if (jsModules.length === 1) {
        return jsModules[0];
      } // Look at the current imports and grab what is already imported for the
      // variable.


      var matchingImportStatement = this.findCurrentImports().imports.find(function (ist) {
        return ist.hasVariable(variableName);
      });

      if (!matchingImportStatement) {
        return undefined;
      }

      if (jsModules.length > 0) {
        // Look for a module matching what is already imported
        var matchingPath = matchingImportStatement.path;
        return jsModules.find(function (jsModule) {
          return matchingPath === jsModule.toImportStatement(_this10.config).path;
        });
      } // We couldn't resolve any module for the variable. As a fallback, we
      // can use the matching import statement. If that maps to a package
      // dependency, we will still open the right file.


      var hasNamedExports = matchingImportStatement.defaultImport !== variableName;
      var matchedModule = new _JsModule.default({
        importPath: matchingImportStatement.path,
        hasNamedExports: hasNamedExports,
        variableName: variableName
      });
      return matchedModule;
    }
  }, {
    key: "injectSideEffectImports",
    value: function injectSideEffectImports(importStatements) {
      var _this11 = this;

      var addedImports = [];
      this.config.get('moduleSideEffectImports').forEach(function (path) {
        var sizeBefore = importStatements.size();
        importStatements.push(new _ImportStatement.default({
          namedImports: [],
          defaultImport: '',
          hasSideEffects: true,
          declarationKeyword: _this11.config.get('declarationKeyword'),
          importFunction: _this11.config.get('importFunction'),
          danglingCommas: _this11.config.get('danglingCommas'),
          path: path
        }));

        if (importStatements.size() > sizeBefore) {
          // The number of imports changed as part of adding the side-effect
          // import. This means that the import wasn't previously there.
          addedImports.push("'".concat(path, "'"));
        }
      });
      return addedImports;
    }
  }]);

  return Importer;
}();

exports.default = Importer;