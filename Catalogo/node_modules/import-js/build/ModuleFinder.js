"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _requireRelative = _interopRequireDefault(require("require-relative"));

var _winston = _interopRequireDefault(require("winston"));

var _ExportsStorage = _interopRequireDefault(require("./ExportsStorage"));

var _Watcher = _interopRequireDefault(require("./Watcher"));

var _findExports = _interopRequireDefault(require("./findExports"));

var _findPackageDependencies = _interopRequireDefault(require("./findPackageDependencies"));

var _lastUpdate = _interopRequireDefault(require("./lastUpdate"));

var _readFile = _interopRequireDefault(require("./readFile"));

var _forwardSlashes = _interopRequireDefault(require("./forwardSlashes"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Checks for package.json or npm-shrinkwrap.json inside a list of files and
 * expands the list of files to include package dependencies if so.
 */
function expandFiles(files, workingDirectory) {
  var promises = [];
  files.forEach(function (file) {
    if (file.path !== './package.json' && file.path !== './npm-shrinkwrap.json') {
      promises.push(Promise.resolve(file));
      return;
    }

    (0, _findPackageDependencies.default)(workingDirectory, true).forEach(function (dep) {
      var resolvedPath;

      try {
        resolvedPath = (0, _forwardSlashes.default)(_path.default.relative(workingDirectory, _requireRelative.default.resolve(dep, workingDirectory)));

        if (!resolvedPath.startsWith('.')) {
          // path.relative won't add "./", but we need it further down the line
          resolvedPath = "./".concat(resolvedPath);
        }
      } catch (e) {
        _winston.default.error("Failed to resolve \"".concat(dep, "\" relative to ").concat(workingDirectory));

        return;
      }

      promises.push(_lastUpdate.default.failSafe(resolvedPath, workingDirectory).then(function (_ref) {
        var mtime = _ref.mtime;
        return Promise.resolve({
          path: resolvedPath,
          mtime: mtime,
          packageName: dep
        });
      }));
    });
  });
  return Promise.all(promises);
}

function aliasedExportNames(alias, ignorePackagePrefixes) {
  var result = [{
    name: alias
  }];
  ignorePackagePrefixes.forEach(function (prefix) {
    if (alias.startsWith(prefix)) {
      result.push({
        name: alias.slice(prefix.length)
      });
    }
  });
  return result;
}

function defaultExportNames(pathToFile) {
  var parsed = _path.default.parse(pathToFile);

  var fileName = parsed.name;

  var dirName = _path.default.basename(parsed.dir);

  if (/package\.json|index\.[jt]sx?/.test(parsed.base)) {
    fileName = dirName;
    dirName = _path.default.basename(_path.default.dirname(parsed.dir));
  }

  if (dirName === '.') {
    return [{
      name: fileName
    }];
  }

  var result = [{
    name: "".concat(dirName, "-").concat(fileName),
    additional: true
  }, {
    name: fileName
  }];

  if (/e?s$/.test(dirName)) {
    // When the directory has an "s" (or "es") at the end, we assume it's a
    // plural form of something. We then add a third name to the list. As an
    // example, if we have './mocks/ModuleFinder.js' as the pathToFile, we add
    // 'mock-ModuleFinder' here, which will allow the user to find the module
    // with `MockModuleFinder` as the variable name.
    result.push({
      name: "".concat(dirName.replace(/e?s$/, ''), "-").concat(fileName),
      additional: true
    });
  }

  return result;
}

var instances = {};

var ModuleFinder =
/*#__PURE__*/
function () {
  _createClass(ModuleFinder, null, [{
    key: "getForWorkingDirectory",

    /**
     * Factory method to get an instance for a specific working directory.
     */
    value: function getForWorkingDirectory(workingDirectory, _ref2) {
      var excludes = _ref2.excludes,
          ignorePackagePrefixes = _ref2.ignorePackagePrefixes;
      var instance = instances[workingDirectory];

      if (!instance) {
        instance = new ModuleFinder(workingDirectory, {
          excludes: excludes,
          ignorePackagePrefixes: ignorePackagePrefixes
        });
        instances[workingDirectory] = instance;
      }

      return instance;
    }
  }]);

  function ModuleFinder(workingDirectory, _ref3) {
    var excludes = _ref3.excludes,
        ignorePackagePrefixes = _ref3.ignorePackagePrefixes;

    _classCallCheck(this, ModuleFinder);

    this.excludes = excludes;
    this.ignorePackagePrefixes = ignorePackagePrefixes;
    this.workingDirectory = workingDirectory;
    this.storage = new _ExportsStorage.default();
    this.watcher = new _Watcher.default({
      workingDirectory: workingDirectory,
      excludes: excludes,
      onFilesAdded: this.handleFilesAdded.bind(this),
      onFilesRemoved: this.handleFilesRemoved.bind(this),
      storage: this.storage
    });
    this.queue = [];
    this.processingQueue = false;
  }

  _createClass(ModuleFinder, [{
    key: "initializeStorage",
    value: function initializeStorage(dbFilename) {
      var _this = this;

      return this.storage.init(dbFilename).then(function (_ref4) {
        var isFreshInstall = _ref4.isFreshInstall;
        return Promise.all(_this.excludes.map(function (glob) {
          return _this.storage.removeAll(glob);
        })).then(function () {
          return _this.storage.purgeDeadNodeModules(_this.workingDirectory);
        }).then(function () {
          return Promise.resolve({
            isFreshInstall: isFreshInstall
          });
        });
      });
    }
  }, {
    key: "startWatcher",
    value: function startWatcher() {
      return this.watcher.initialize();
    }
  }, {
    key: "processQueue",
    value: function processQueue(done) {
      var _this2 = this;

      var file = this.queue.pop();

      if (!file) {
        this.processingQueue = false;

        _winston.default.debug('Queue empty');

        done();
        return;
      }

      var pathToFile = file.path,
          mtime = file.mtime,
          packageName = file.packageName;
      this.processingQueue = true;

      _winston.default.debug("Processing ".concat(pathToFile));

      var fullPath = _path.default.join(this.workingDirectory, pathToFile);

      (0, _readFile.default)(fullPath).then(function (data) {
        var exports = {
          named: [],
          typed: [],
          hasDefault: true
        };

        try {
          exports = (0, _findExports.default)(data, fullPath);
        } catch (e) {
          _winston.default.error("Failed to parse ".concat(pathToFile, ": ").concat(e.message, "\n").concat(e.stack));
        }

        if (exports.named.length || exports.typed.length || exports.hasDefault) {
          var all = _toConsumableArray(exports.named).concat(_toConsumableArray(exports.typed.map(function (t) {
            return "type ".concat(t);
          })));

          if (exports.hasDefault) {
            all.push('default');
          }

          _winston.default.debug("Found exports for ".concat(pathToFile, ":\n").concat(all.join(', ')));
        } else {
          _winston.default.debug("No exports found for ".concat(pathToFile));
        }

        var defaultNames = [];

        if (exports.hasDefault) {
          if (packageName) {
            defaultNames.push.apply(defaultNames, _toConsumableArray(aliasedExportNames(packageName, _this2.ignorePackagePrefixes)));
          } else {
            defaultNames.push.apply(defaultNames, _toConsumableArray(defaultExportNames(pathToFile)));
          }
        }

        _this2.storage.update({
          names: exports.named,
          types: exports.typed,
          defaultNames: defaultNames,
          pathToFile: pathToFile,
          mtime: mtime,
          packageName: packageName
        }).then(function () {
          _this2.processQueue(done);
        }).catch(function (error) {
          _winston.default.error("Failed to update ".concat(pathToFile, " in storage. Reason: ").concat(error.message));

          _this2.processQueue(done);
        });
      }).catch(function (err) {
        _winston.default.error(err.message);

        _this2.processQueue(done);
      });
    }
  }, {
    key: "handleFilesAdded",
    value: function handleFilesAdded(unexpandedFiles) {
      var _this3 = this;

      return new Promise(function (resolve) {
        expandFiles(unexpandedFiles, _this3.workingDirectory).then(function (files) {
          _winston.default.debug("Checking ".concat(files.length, " files for potential updates"));

          _this3.storage.needsUpdate(files).then(function (filesToUpdate) {
            _winston.default.debug("Got ".concat(filesToUpdate.length, " files to update"));

            if (!filesToUpdate.length) {
              resolve();
              return;
            }

            filesToUpdate.forEach(function (file) {
              _this3.queue.unshift(file);

              if (!_this3.processingQueue) {
                _winston.default.debug('Kicking off queue');

                _this3.processQueue(resolve);
              }
            });
          });
        });
      });
    }
  }, {
    key: "handleFilesRemoved",
    value: function handleFilesRemoved(files) {
      var _this4 = this;

      if (!files.length) {
        return Promise.resolve();
      }

      _winston.default.debug("Removing ".concat(files.length, " files"));

      var promises = files.map(function (_ref5) {
        var pathToFile = _ref5.path;

        _winston.default.debug("Removing ".concat(pathToFile));

        return _this4.storage.remove(pathToFile);
      });
      return Promise.all(promises);
    }
  }, {
    key: "find",
    value: function find(variableName) {
      return this.storage.get(variableName);
    }
  }, {
    key: "search",
    value: function search(variableName) {
      return this.storage.search(variableName);
    }
  }]);

  return ModuleFinder;
}();

exports.default = ModuleFinder;