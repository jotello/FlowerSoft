"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = visitIdentifierNodes;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

var KEYS_USED_FOR_ASSIGNMENT = new Set(['id', 'imported', 'local', 'params']);
var KEYS_USED_IN_REFERENCE_TO_OBJECTS = new Set(['property']);

function normalizeNode(node, context) {
  var key = context.key,
      parent = context.parent;

  if (!parent) {
    return undefined;
  }

  if (node.type === 'JSXIdentifier') {
    if (key !== 'name' && key !== 'object') {
      return undefined;
    }

    if (parent.type === 'JSXOpeningElement' || parent.type === 'JSXMemberExpression' && parent.parent.type === 'JSXOpeningElement') {
      return {
        name: node.name,
        isJSX: true,
        context: context
      };
    }
  }

  if (parent.type === 'GenericTypeAnnotation') {
    if (!node.name) {
      return undefined;
    } // flow


    return {
      name: node.name,
      context: context
    };
  }

  if (node.type !== 'Identifier') {
    return undefined;
  }

  if (parent.type === 'ExportSpecifier') {
    if (key === 'exported') {
      // "bar" in `export { foo from bar }`
      return undefined;
    }

    if (key === 'local') {
      // "foo" in `export { foo from bar }`
      return {
        name: node.name,
        context: context
      };
    }
  }

  var isAssignment = KEYS_USED_FOR_ASSIGNMENT.has(key) || key === 'key' && parent.parent.type === 'ObjectPattern' || key === 'left' && parent.type === 'AssignmentPattern' || key === 'elements' && parent.type === 'ArrayPattern' || key === 'argument' && parent.type === 'RestElement' || key === 'value' && parent.parent.type === 'ObjectPattern' && parent.parent.parent.type === 'VariableDeclarator';

  if (isAssignment) {
    context.definedInScope.add(node.name);
  }

  var isReference = KEYS_USED_IN_REFERENCE_TO_OBJECTS.has(key) || key === 'key' && !parent.computed && parent.parent.type !== 'ObjectPattern';
  return {
    isReference: isReference,
    isAssignment: isAssignment,
    context: context,
    name: node.name
  };
}

function visitIdentifierNodes(rootAstNode, visitor) {
  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    definedInScope: new Set([]),
    key: 'root'
  };
  var queue = [{
    node: rootAstNode,
    context: context
  }];
  var current;

  var _loop = function _loop() {
    current = queue.shift();

    if (Array.isArray(current.node)) {
      if (current.context.key === 'body') {
        // A new scope has started. Copy whatever we have from the parent scope
        // into a new one.
        current.context.definedInScope = new Set(_toConsumableArray(current.context.definedInScope));
      } // eslint-disable-next-line no-loop-func


      var _itemsToAdd = current.node.map(function (node) {
        return {
          node: node,
          context: current.context
        };
      });

      queue.unshift.apply(queue, _toConsumableArray(_itemsToAdd));
      return "continue"; // eslint-disable-line no-continue
    }

    var normalizedNode = normalizeNode(current.node, current.context);

    if (normalizedNode) {
      visitor(normalizedNode, current.context);
    }

    var itemsToAdd = []; // eslint-disable-next-line no-loop-func

    Object.keys(current.node).forEach(function (key) {
      if (!current.node[key] || _typeof(current.node[key]) !== 'object') {
        return;
      }

      var newContext = Object.assign({}, current.context, {
        key: key,
        parent: {
          type: current.node.type,
          parent: current.context.parent,
          computed: current.node.computed
        }
      });
      var itemToPush = {
        node: current.node[key],
        context: newContext
      };

      if (key === 'body') {
        // Delay traversing function bodies, so that we can finish finding all
        // defined variables in scope first.
        queue.push(itemToPush);
      } else {
        itemsToAdd.push(itemToPush);
      }
    });
    queue.unshift.apply(queue, itemsToAdd);
  };

  while (queue.length) {
    var _ret = _loop();

    if (_ret === "continue") continue;
  }
}